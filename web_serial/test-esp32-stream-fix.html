<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ESP32 æµç®¡ç†ä¿®å¤æµ‹è¯•</title>
    <style>
        body {
            font-family: 'Microsoft YaHei', Arial, sans-serif;
            margin: 20px;
            background: #f5f5f5;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        .test-section {
            margin: 20px 0;
            padding: 15px;
            border: 1px solid #ddd;
            border-radius: 5px;
            background: #fafafa;
        }
        .test-header {
            font-size: 18px;
            font-weight: bold;
            color: #333;
            margin-bottom: 10px;
        }
        button {
            background: #007cba;
            color: white;
            border: none;
            padding: 8px 15px;
            margin: 5px;
            border-radius: 4px;
            cursor: pointer;
        }
        button:hover {
            background: #005a8c;
        }
        button:disabled {
            background: #ccc;
            cursor: not-allowed;
        }
        .log-output {
            background: #1e1e1e;
            color: #d4d4d4;
            padding: 15px;
            border-radius: 4px;
            height: 300px;
            overflow-y: auto;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 13px;
            margin: 10px 0;
        }
        .status {
            padding: 10px;
            margin: 10px 0;
            border-radius: 4px;
            font-weight: bold;
        }
        .status.success { background: #d4edda; color: #155724; border: 1px solid #c3e6cb; }
        .status.error { background: #f8d7da; color: #721c24; border: 1px solid #f5c6cb; }
        .status.warning { background: #fff3cd; color: #856404; border: 1px solid #ffeaa7; }
        .status.info { background: #cce7ff; color: #004085; border: 1px solid #99d3ff; }
        .progress {
            width: 100%;
            height: 20px;
            background: #e9ecef;
            border-radius: 10px;
            overflow: hidden;
            margin: 10px 0;
        }
        .progress-bar {
            height: 100%;
            background: linear-gradient(45deg, #007cba, #28a745);
            transition: width 0.3s;
            border-radius: 10px;
        }
        .chip-info {
            background: #e7f3ff;
            padding: 10px;
            border-left: 4px solid #007cba;
            margin: 10px 0;
        }
        .file-input {
            margin: 10px 0;
            padding: 10px;
            border: 2px dashed #ddd;
            border-radius: 5px;
            text-align: center;
        }
        .test-results {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 15px;
            margin: 20px 0;
        }
        .test-item {
            padding: 15px;
            border: 1px solid #ddd;
            border-radius: 5px;
            background: white;
        }
        .test-item.pass { border-left: 4px solid #28a745; }
        .test-item.fail { border-left: 4px solid #dc3545; }
        .test-item.pending { border-left: 4px solid #ffc107; }
    </style>
</head>
<body>
    <div class="container">
        <h1>ğŸ”§ ESP32 æµç®¡ç†ä¿®å¤æµ‹è¯•</h1>
        <p>æµ‹è¯•ä¿®å¤åçš„ESP32ä¸‹è½½å™¨çš„æµç®¡ç†åŠŸèƒ½ï¼ŒéªŒè¯reader/writeré”å®šå†²çªé—®é¢˜æ˜¯å¦å·²è§£å†³ã€‚</p>

        <!-- ä¾èµ–åŠ è½½æµ‹è¯• -->
        <div class="test-section">
            <div class="test-header">ğŸ“¦ ä¾èµ–åŠ è½½æµ‹è¯•</div>
            <button onclick="testDependencies()">æ£€æŸ¥ä¾èµ–</button>
            <div id="dependencies-status" class="status info">ç­‰å¾…æµ‹è¯•...</div>
        </div>

        <!-- ä¸²å£è¿æ¥æµ‹è¯• -->
        <div class="test-section">
            <div class="test-header">ğŸ”Œ ä¸²å£è¿æ¥æµ‹è¯•</div>
            <button onclick="connectSerial()">è¿æ¥ä¸²å£</button>
            <button onclick="disconnectSerial()" disabled>æ–­å¼€ä¸²å£</button>
            <div id="serial-status" class="status info">æœªè¿æ¥</div>
            <div id="chip-info" class="chip-info" style="display: none;">
                <h4>èŠ¯ç‰‡ä¿¡æ¯</h4>
                <div id="chip-details"></div>
            </div>
        </div>

        <!-- æµçŠ¶æ€æµ‹è¯• -->
        <div class="test-section">
            <div class="test-header">ğŸŒŠ æµçŠ¶æ€æµ‹è¯•</div>
            <button onclick="testStreamStatus()">æ£€æŸ¥æµçŠ¶æ€</button>
            <button onclick="testStreamLocking()">æµ‹è¯•æµé”å®šå¤„ç†</button>
            <div id="stream-status" class="status info">ç­‰å¾…æµ‹è¯•...</div>
        </div>

        <!-- å›ºä»¶ä¸‹è½½æµ‹è¯• -->
        <div class="test-section">
            <div class="test-header">ğŸ“¥ å›ºä»¶ä¸‹è½½æµ‹è¯•</div>
            <div class="file-input">
                <input type="file" id="firmware-file" accept=".bin" />
                <p>é€‰æ‹©å›ºä»¶æ–‡ä»¶ (.bin)</p>
            </div>
            <div>
                èµ·å§‹åœ°å€: <input type="text" id="start-addr" value="0x10000" style="margin-left: 10px;" />
            </div>
            <button onclick="testFirmwareDownload()">å¼€å§‹ä¸‹è½½æµ‹è¯•</button>
            <button onclick="stopDownload()" disabled>åœæ­¢ä¸‹è½½</button>
            <div class="progress">
                <div id="download-progress" class="progress-bar" style="width: 0%;"></div>
            </div>
            <div id="download-status" class="status info">ç­‰å¾…æµ‹è¯•...</div>
        </div>

        <!-- æµ‹è¯•ç»“æœæ±‡æ€» -->
        <div class="test-section">
            <div class="test-header">ğŸ“Š æµ‹è¯•ç»“æœæ±‡æ€»</div>
            <div id="test-results" class="test-results">
                <div class="test-item pending">
                    <h4>ä¾èµ–åŠ è½½</h4>
                    <div id="test-deps-result">å¾…æµ‹è¯•</div>
                </div>
                <div class="test-item pending">
                    <h4>ä¸²å£è¿æ¥</h4>
                    <div id="test-serial-result">å¾…æµ‹è¯•</div>
                </div>
                <div class="test-item pending">
                    <h4>æµç®¡ç†</h4>
                    <div id="test-stream-result">å¾…æµ‹è¯•</div>
                </div>
                <div class="test-item pending">
                    <h4>å›ºä»¶ä¸‹è½½</h4>
                    <div id="test-download-result">å¾…æµ‹è¯•</div>
                </div>
            </div>
        </div>

        <!-- è¯¦ç»†æ—¥å¿— -->
        <div class="test-section">
            <div class="test-header">ğŸ“ è¯¦ç»†æ—¥å¿—</div>
            <button onclick="clearLog()">æ¸…ç©ºæ—¥å¿—</button>
            <button onclick="saveLog()">ä¿å­˜æ—¥å¿—</button>
            <div id="log-output" class="log-output"></div>
        </div>
    </div>

    <!-- ä¾èµ–è„šæœ¬ -->
    <script src="i18n/zh.js"></script>
    <script src="third_party/esptool-js-umd.bundle.js"></script>
    <script src="esp-protocol-reuse.js"></script>
    <script src="downloaders/base-downloader.js"></script>
    <script src="downloaders/downloader-manager.js"></script>
    <script src="downloaders/esp32-series-downloader.js"></script>
    <script src="flash-downloader.js"></script>
    <script src="script-clean.js"></script>

    <script>
        // å…¨å±€å˜é‡
        let serialTerminal = null;
        let flashDownloader = null;
        let testResults = {
            dependencies: false,
            serial: false,
            stream: false,
            download: false
        };

        // æ—¥å¿—å‡½æ•°
        function log(message, level = 'info') {
            const timestamp = new Date().toLocaleTimeString();
            const logOutput = document.getElementById('log-output');
            const colorMap = {
                info: '#4a9eff',
                success: '#28a745',
                warning: '#ffc107',
                error: '#dc3545',
                debug: '#6c757d'
            };
            
            const color = colorMap[level] || '#d4d4d4';
            logOutput.innerHTML += `<div style="color: ${color};">[${timestamp}] ${message}</div>`;
            logOutput.scrollTop = logOutput.scrollHeight;
            console.log(`[${timestamp}] ${message}`);
        }

        function clearLog() {
            document.getElementById('log-output').innerHTML = '';
        }

        function saveLog() {
            const logContent = document.getElementById('log-output').innerText;
            const blob = new Blob([logContent], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `esp32-test-log-${new Date().toISOString().slice(0,19).replace(/:/g,'-')}.txt`;
            a.click();
            URL.revokeObjectURL(url);
        }

        function updateStatus(elementId, message, level = 'info') {
            const element = document.getElementById(elementId);
            element.textContent = message;
            element.className = `status ${level}`;
        }

        function updateTestResult(testName, passed, details) {
            testResults[testName] = passed;
            const resultElement = document.getElementById(`test-${testName}-result`);
            const itemElement = resultElement.closest('.test-item');
            
            resultElement.textContent = details;
            itemElement.className = `test-item ${passed ? 'pass' : 'fail'}`;
        }

        // ä¾èµ–æµ‹è¯•
        async function testDependencies() {
            log('å¼€å§‹æ£€æŸ¥ä¾èµ–...', 'info');
            let allPassed = true;
            let details = [];

            try {
                // æ£€æŸ¥i18n
                if (typeof zh !== 'undefined' && zh.title) {
                    // åˆ›å»ºç®€å•çš„i18nå‡½æ•°ç”¨äºæµ‹è¯•
                    if (typeof i18n === 'undefined') {
                        window.i18n = {
                            t: (key, ...args) => {
                                let text = zh[key] || key;
                                args.forEach((arg, index) => {
                                    text = text.replace(new RegExp(`\\{${index}\\}`, 'g'), arg);
                                });
                                return text;
                            }
                        };
                    }
                    log('âœ… i18n åŠ è½½æˆåŠŸ', 'success');
                    details.push('i18n: âœ…');
                } else {
                    log('âŒ i18n æœªåŠ è½½', 'error');
                    details.push('i18n: âŒ');
                    allPassed = false;
                }

                // æ£€æŸ¥esptool-js
                if (typeof ESPLoader !== 'undefined' || 
                    (typeof window.esptooljs !== 'undefined' && window.esptooljs.ESPLoader)) {
                    log('âœ… esptool-js åŠ è½½æˆåŠŸ', 'success');
                    details.push('esptool-js: âœ…');
                } else {
                    log('âŒ esptool-js æœªåŠ è½½', 'error');
                    details.push('esptool-js: âŒ');
                    allPassed = false;
                }

                // æ£€æŸ¥ä¸‹è½½å™¨
                if (typeof BaseDownloader !== 'undefined') {
                    log('âœ… BaseDownloader å¯ç”¨', 'success');
                    details.push('BaseDownloader: âœ…');
                } else {
                    log('âŒ BaseDownloader æœªæ‰¾åˆ°', 'error');
                    details.push('BaseDownloader: âŒ');
                    allPassed = false;
                }

                if (typeof ESP32SeriesDownloader !== 'undefined') {
                    log('âœ… ESP32SeriesDownloader å¯ç”¨', 'success');
                    details.push('ESP32SeriesDownloader: âœ…');
                } else {
                    log('âŒ ESP32SeriesDownloader æœªæ‰¾åˆ°', 'error');
                    details.push('ESP32SeriesDownloader: âŒ');
                    allPassed = false;
                }

                if (typeof FlashDownloader !== 'undefined') {
                    log('âœ… FlashDownloader å¯ç”¨', 'success');
                    details.push('FlashDownloader: âœ…');
                } else {
                    log('âŒ FlashDownloader æœªæ‰¾åˆ°', 'error');
                    details.push('FlashDownloader: âŒ');
                    allPassed = false;
                }

                // æ£€æŸ¥Web Serial API
                if ('serial' in navigator) {
                    log('âœ… Web Serial API æ”¯æŒ', 'success');
                    details.push('Web Serial: âœ…');
                } else {
                    log('âŒ Web Serial API ä¸æ”¯æŒ', 'error');
                    details.push('Web Serial: âŒ');
                    allPassed = false;
                }

                updateStatus('dependencies-status', 
                    allPassed ? 'æ‰€æœ‰ä¾èµ–æ£€æŸ¥é€šè¿‡' : 'éƒ¨åˆ†ä¾èµ–ç¼ºå¤±', 
                    allPassed ? 'success' : 'error');
                
                updateTestResult('deps', allPassed, details.join(', '));
                log(`ä¾èµ–æ£€æŸ¥å®Œæˆ: ${allPassed ? 'é€šè¿‡' : 'å¤±è´¥'}`, allPassed ? 'success' : 'error');

            } catch (error) {
                log(`ä¾èµ–æ£€æŸ¥å‡ºé”™: ${error.message}`, 'error');
                updateStatus('dependencies-status', `æ£€æŸ¥å¤±è´¥: ${error.message}`, 'error');
                updateTestResult('deps', false, `é”™è¯¯: ${error.message}`);
            }
        }

        // ä¸²å£è¿æ¥æµ‹è¯•
        async function connectSerial() {
            log('å¼€å§‹è¿æ¥ä¸²å£...', 'info');
            
            try {
                // ç›´æ¥ä½¿ç”¨Web Serial APIï¼Œé¿å…SerialTerminalçš„å¤æ‚ä¾èµ–
                if (!serialTerminal) {
                    const port = await navigator.serial.requestPort();
                    await port.open({
                        baudRate: 115200,
                        dataBits: 8,
                        stopBits: 1,
                        parity: 'none'
                    });
                    
                    // åˆ›å»ºç®€åŒ–çš„ä¸²å£å¯¹è±¡
                    serialTerminal = {
                        flashPort: port,
                        isFlashConnected: true,
                        flashReader: null,
                        flashWriter: null
                    };
                }
                
                log('ä¸²å£è¿æ¥æˆåŠŸ', 'success');
                updateStatus('serial-status', 'å·²è¿æ¥', 'success');
                
                document.querySelector('button[onclick="connectSerial()"]').disabled = true;
                document.querySelector('button[onclick="disconnectSerial()"]').disabled = false;

                // å°è¯•è·å–èŠ¯ç‰‡ä¿¡æ¯
                try {
                    await testChipDetection();
                } catch (chipError) {
                    log(`èŠ¯ç‰‡æ£€æµ‹å¤±è´¥: ${chipError.message}`, 'warning');
                }

                updateTestResult('serial', true, 'è¿æ¥æˆåŠŸ');

            } catch (error) {
                log(`ä¸²å£è¿æ¥å¤±è´¥: ${error.message}`, 'error');
                updateStatus('serial-status', `è¿æ¥å¤±è´¥: ${error.message}`, 'error');
                updateTestResult('serial', false, `è¿æ¥å¤±è´¥: ${error.message}`);
            }
        }

        async function disconnectSerial() {
            if (serialTerminal && serialTerminal.isFlashConnected) {
                try {
                    // é‡Šæ”¾reader/writer
                    if (serialTerminal.flashReader) {
                        await serialTerminal.flashReader.releaseLock();
                        serialTerminal.flashReader = null;
                    }
                    if (serialTerminal.flashWriter) {
                        await serialTerminal.flashWriter.releaseLock();
                        serialTerminal.flashWriter = null;
                    }
                    
                    // å…³é—­ä¸²å£
                    await serialTerminal.flashPort.close();
                    serialTerminal.isFlashConnected = false;
                    
                    log('ä¸²å£å·²æ–­å¼€', 'info');
                    updateStatus('serial-status', 'å·²æ–­å¼€', 'info');
                    
                    document.querySelector('button[onclick="connectSerial()"]').disabled = false;
                    document.querySelector('button[onclick="disconnectSerial()"]').disabled = true;
                    
                    document.getElementById('chip-info').style.display = 'none';
                } catch (error) {
                    log(`æ–­å¼€ä¸²å£æ—¶å‘ç”Ÿé”™è¯¯: ${error.message}`, 'warning');
                }
            }
        }

        async function testChipDetection() {
            log('å¼€å§‹æ£€æµ‹ESP32èŠ¯ç‰‡...', 'info');
            
            try {
                // åˆå§‹åŒ–ä¸‹è½½å™¨ç®¡ç†å™¨
                if (typeof window.downloaderManager === 'undefined') {
                    window.downloaderManager = new DownloaderManager();
                }

                // åˆ›å»ºESP32ä¸‹è½½å™¨è¿›è¡ŒèŠ¯ç‰‡æ£€æµ‹
                const downloader = await window.downloaderManager.createDownloader(
                    'ESP32', 
                    serialTerminal.flashPort,
                    (level, message) => log(message, level)
                );

                const connected = await downloader.connect();
                if (connected) {
                    const chipInfo = downloader.getChipInfo();
                    
                    document.getElementById('chip-details').innerHTML = `
                        <p><strong>èŠ¯ç‰‡ç±»å‹:</strong> ${chipInfo.name}</p>
                        <p><strong>MACåœ°å€:</strong> ${chipInfo.macAddress}</p>
                        <p><strong>Flashå¤§å°:</strong> ${chipInfo.flashSize}</p>
                        <p><strong>èŠ¯ç‰‡ç‰ˆæœ¬:</strong> ${chipInfo.revision}</p>
                        <p><strong>ç‰¹æ€§:</strong> ${chipInfo.features.join(', ')}</p>
                    `;
                    document.getElementById('chip-info').style.display = 'block';
                    
                    log(`èŠ¯ç‰‡æ£€æµ‹æˆåŠŸ: ${chipInfo.name}`, 'success');
                    
                    await downloader.disconnect();
                }
            } catch (error) {
                log(`èŠ¯ç‰‡æ£€æµ‹å¤±è´¥: ${error.message}`, 'warning');
            }
        }

        // æµçŠ¶æ€æµ‹è¯•
        async function testStreamStatus() {
            log('å¼€å§‹æ£€æŸ¥æµçŠ¶æ€...', 'info');
            
            if (!serialTerminal || !serialTerminal.isFlashConnected) {
                updateStatus('stream-status', 'è¯·å…ˆè¿æ¥ä¸²å£', 'warning');
                return;
            }

            try {
                const port = serialTerminal.flashPort;
                const status = {
                    readable: !!port.readable,
                    writable: !!port.writable,
                    readableLocked: port.readable ? port.readable.locked : false,
                    writableLocked: port.writable ? port.writable.locked : false
                };

                log(`æµçŠ¶æ€æ£€æŸ¥:`);
                log(`- å¯è¯»æµ: ${status.readable ? 'å¯ç”¨' : 'ä¸å¯ç”¨'}`);
                log(`- å¯å†™æµ: ${status.writable ? 'å¯ç”¨' : 'ä¸å¯ç”¨'}`);
                log(`- å¯è¯»æµé”å®š: ${status.readableLocked ? 'æ˜¯' : 'å¦'}`);
                log(`- å¯å†™æµé”å®š: ${status.writableLocked ? 'æ˜¯' : 'å¦'}`);

                const healthy = status.readable && status.writable && !status.readableLocked && !status.writableLocked;
                
                updateStatus('stream-status', 
                    healthy ? 'æµçŠ¶æ€æ­£å¸¸' : 'æµçŠ¶æ€å¼‚å¸¸', 
                    healthy ? 'success' : 'warning');
                
                updateTestResult('stream', healthy, 
                    `è¯»:${status.readable?'âœ…':'âŒ'} å†™:${status.writable?'âœ…':'âŒ'} é”å®š:${status.readableLocked||status.writableLocked?'âŒ':'âœ…'}`);

            } catch (error) {
                log(`æ£€æŸ¥æµçŠ¶æ€å‡ºé”™: ${error.message}`, 'error');
                updateStatus('stream-status', `æ£€æŸ¥å¤±è´¥: ${error.message}`, 'error');
                updateTestResult('stream', false, `é”™è¯¯: ${error.message}`);
            }
        }

        async function testStreamLocking() {
            log('å¼€å§‹æµ‹è¯•æµé”å®šå¤„ç†...', 'info');
            
            if (!serialTerminal || !serialTerminal.isFlashConnected) {
                updateStatus('stream-status', 'è¯·å…ˆè¿æ¥ä¸²å£', 'warning');
                return;
            }

            try {
                // æ¨¡æ‹Ÿé”å®šå†²çªåœºæ™¯
                log('æ¨¡æ‹Ÿè·å–reader/writer...', 'debug');
                
                const reader = serialTerminal.flashPort.readable.getReader();
                const writer = serialTerminal.flashPort.writable.getWriter();
                
                log('âœ… æˆåŠŸè·å–reader/writer', 'success');
                
                // æµ‹è¯•é‡å¤è·å–ï¼ˆåº”è¯¥å¤±è´¥ï¼‰
                try {
                    const reader2 = serialTerminal.flashPort.readable.getReader();
                    log('âŒ æ„å¤–æˆåŠŸè·å–ç¬¬äºŒä¸ªreader', 'error');
                    reader2.releaseLock();
                } catch (lockError) {
                    log('âœ… æ­£ç¡®æ£€æµ‹åˆ°readeré”å®šå†²çª', 'success');
                }
                
                // é‡Šæ”¾èµ„æº
                await reader.releaseLock();
                await writer.releaseLock();
                
                log('âœ… æˆåŠŸé‡Šæ”¾reader/writer', 'success');
                
                // ç­‰å¾…ä¸€æ®µæ—¶é—´åé‡æ–°è·å–
                await new Promise(resolve => setTimeout(resolve, 100));
                
                const reader3 = serialTerminal.flashPort.readable.getReader();
                const writer3 = serialTerminal.flashPort.writable.getWriter();
                
                log('âœ… é‡Šæ”¾åæˆåŠŸé‡æ–°è·å–reader/writer', 'success');
                
                await reader3.releaseLock();
                await writer3.releaseLock();
                
                updateStatus('stream-status', 'æµé”å®šå¤„ç†æµ‹è¯•é€šè¿‡', 'success');
                updateTestResult('stream', true, 'é”å®šå¤„ç†æ­£å¸¸');

            } catch (error) {
                log(`æµé”å®šæµ‹è¯•å‡ºé”™: ${error.message}`, 'error');
                updateStatus('stream-status', `æµ‹è¯•å¤±è´¥: ${error.message}`, 'error');
                updateTestResult('stream', false, `é”™è¯¯: ${error.message}`);
            }
        }

        // å›ºä»¶ä¸‹è½½æµ‹è¯•
        async function testFirmwareDownload() {
            const fileInput = document.getElementById('firmware-file');
            const startAddrInput = document.getElementById('start-addr');
            
            if (!fileInput.files[0]) {
                updateStatus('download-status', 'è¯·é€‰æ‹©å›ºä»¶æ–‡ä»¶', 'warning');
                return;
            }

            if (!serialTerminal || !serialTerminal.isFlashConnected) {
                updateStatus('download-status', 'è¯·å…ˆè¿æ¥ä¸²å£', 'warning');
                return;
            }

            const file = fileInput.files[0];
            const startAddr = parseInt(startAddrInput.value, 16);
            
            log(`å¼€å§‹å›ºä»¶ä¸‹è½½æµ‹è¯•: ${file.name} (${file.size} å­—èŠ‚) @ 0x${startAddr.toString(16)}`, 'info');

            try {
                // è¯»å–æ–‡ä»¶æ•°æ®
                const arrayBuffer = await file.arrayBuffer();
                const fileData = new Uint8Array(arrayBuffer);

                // åˆ›å»ºFlashDownloader
                if (!flashDownloader) {
                    flashDownloader = new FlashDownloader(serialTerminal, {
                        debug: true,
                        onProgress: (progress) => {
                            if (progress.type === 'progress') {
                                const percent = Math.round(progress.percentage || 0);
                                document.getElementById('download-progress').style.width = `${percent}%`;
                                log(`ä¸‹è½½è¿›åº¦: ${percent}%`, 'info');
                            } else if (progress.type === 'log') {
                                log(progress.message, progress.level);
                            }
                        }
                    });
                }

                // å¯ç”¨æŒ‰é’®æ§åˆ¶
                document.querySelector('button[onclick="testFirmwareDownload()"]').disabled = true;
                document.querySelector('button[onclick="stopDownload()"]').disabled = false;

                updateStatus('download-status', 'æ­£åœ¨ä¸‹è½½...', 'info');

                // å¼€å§‹ä¸‹è½½
                await flashDownloader.downloadBinary(fileData, 'ESP32', startAddr);
                
                log('âœ… å›ºä»¶ä¸‹è½½æµ‹è¯•å®Œæˆ', 'success');
                updateStatus('download-status', 'ä¸‹è½½æµ‹è¯•å®Œæˆ', 'success');
                updateTestResult('download', true, 'ä¸‹è½½æˆåŠŸ');

            } catch (error) {
                log(`å›ºä»¶ä¸‹è½½å¤±è´¥: ${error.message}`, 'error');
                updateStatus('download-status', `ä¸‹è½½å¤±è´¥: ${error.message}`, 'error');
                updateTestResult('download', false, `å¤±è´¥: ${error.message}`);
            } finally {
                // æ¢å¤æŒ‰é’®çŠ¶æ€
                document.querySelector('button[onclick="testFirmwareDownload()"]').disabled = false;
                document.querySelector('button[onclick="stopDownload()"]').disabled = true;
                document.getElementById('download-progress').style.width = '0%';
            }
        }

        async function stopDownload() {
            if (flashDownloader) {
                flashDownloader.stop();
                log('ç”¨æˆ·åœæ­¢ä¸‹è½½', 'warning');
                updateStatus('download-status', 'ä¸‹è½½å·²åœæ­¢', 'warning');
            }
        }

        // é¡µé¢åŠ è½½å®Œæˆåè‡ªåŠ¨å¼€å§‹ä¾èµ–æ£€æŸ¥
        window.addEventListener('load', () => {
            log('ESP32 æµç®¡ç†ä¿®å¤æµ‹è¯•é¡µé¢åŠ è½½å®Œæˆ', 'info');
            log('å¼€å§‹è‡ªåŠ¨æ£€æŸ¥ä¾èµ–...', 'info');
            testDependencies();
        });
    </script>
</body>
</html> 