<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ESP32-Seriesé›†æˆæµ‹è¯•</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
        }
        .test-section {
            margin: 20px 0;
            padding: 15px;
            border: 1px solid #ddd;
            border-radius: 8px;
        }
        .success { background-color: #d4edda; border-color: #c3e6cb; }
        .error { background-color: #f8d7da; border-color: #f5c6cb; }
        .info { background-color: #d1ecf1; border-color: #bee5eb; }
        .warning { background-color: #fff3cd; border-color: #ffeaa7; }
        button {
            padding: 10px 20px;
            margin: 5px;
            border: none;
            border-radius: 4px;
            background-color: #007bff;
            color: white;
            cursor: pointer;
        }
        button:hover { background-color: #0056b3; }
        button:disabled {
            background-color: #6c757d;
            cursor: not-allowed;
        }
        .log {
            background-color: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 4px;
            padding: 10px;
            margin: 10px 0;
            font-family: monospace;
            white-space: pre-wrap;
            max-height: 300px;
            overflow-y: auto;
        }
    </style>
</head>
<body>
    <h1>ESP32-Series é›†æˆæµ‹è¯•</h1>
    
    <div class="test-section" id="loadingTest">
        <h3>1. ä¾èµ–åŠ è½½æµ‹è¯•</h3>
        <div id="loadingResults">æ­£åœ¨æ£€æŸ¥...</div>
    </div>

    <div class="test-section" id="classTest">
        <h3>2. ç±»å®šä¹‰æµ‹è¯•</h3>
        <div id="classResults">æ­£åœ¨æ£€æŸ¥...</div>
    </div>

    <div class="test-section" id="instanceTest">
        <h3>3. å®ä¾‹åˆ›å»ºæµ‹è¯•</h3>
        <button onclick="testInstance()">åˆ›å»ºESP32SeriesDownloaderå®ä¾‹</button>
        <div id="instanceResults"></div>
    </div>

    <div class="test-section" id="methodTest">
        <h3>4. æ–¹æ³•æµ‹è¯•</h3>
        <button onclick="testMethods()" id="methodBtn" disabled>æµ‹è¯•æ‰€æœ‰æ–¹æ³•</button>
        <div id="methodResults"></div>
    </div>

    <div class="test-section" id="serialTest">
        <h3>5. ä¸²å£è¿æ¥æµ‹è¯• (éœ€è¦çœŸå®è®¾å¤‡)</h3>
        <button onclick="testSerialConnection()" id="serialBtn">æµ‹è¯•ä¸²å£è¿æ¥</button>
        <div id="serialResults"></div>
    </div>

    <div class="test-section">
        <h3>æµ‹è¯•æ—¥å¿—</h3>
        <button onclick="clearLog()">æ¸…ç©ºæ—¥å¿—</button>
        <div class="log" id="testLog"></div>
    </div>

    <!-- å¼•å…¥ä¾èµ– -->
    <script type="module">
        import { ESPLoader } from './third_party/esptool-js.bundle.js';
        window.ESPLoader = ESPLoader;
        console.log('âœ… ESPLoader å·²åŠ è½½åˆ°å…¨å±€å˜é‡');
    </script>
    <script src="downloaders/base-downloader.js"></script>
    <script src="downloaders/esp32-series-downloader.js"></script>

    <script>
        let testInstance = null;
        let testLog = [];

        function log(message, type = 'info') {
            const timestamp = new Date().toLocaleTimeString();
            const logMessage = `[${timestamp}] [${type.toUpperCase()}] ${message}`;
            testLog.push(logMessage);
            
            const logElement = document.getElementById('testLog');
            logElement.textContent = testLog.join('\n');
            logElement.scrollTop = logElement.scrollHeight;
            
            console.log(logMessage);
        }

        function clearLog() {
            testLog = [];
            document.getElementById('testLog').textContent = '';
        }

        function updateTestResult(sectionId, content, status = 'info') {
            const section = document.getElementById(sectionId);
            const resultsDiv = section.querySelector('div:last-child');
            resultsDiv.innerHTML = content;
            
            // æ›´æ–°æ ·å¼
            section.className = 'test-section ' + status;
        }

        // 1. æ£€æŸ¥ä¾èµ–åŠ è½½
        function checkDependencies() {
            log('å¼€å§‹æ£€æŸ¥ä¾èµ–åŠ è½½...');
            
            const results = [];
            
            // æ£€æŸ¥ esptool-js
            if (typeof ESPLoader !== 'undefined') {
                results.push('âœ… esptool-js (ESPLoader) å·²åŠ è½½');
                log('esptool-js åŠ è½½æˆåŠŸ');
            } else {
                results.push('âŒ esptool-js (ESPLoader) æœªåŠ è½½');
                log('esptool-js åŠ è½½å¤±è´¥', 'error');
            }

            // æ£€æŸ¥ BaseDownloader
            if (typeof BaseDownloader !== 'undefined') {
                results.push('âœ… BaseDownloader å·²åŠ è½½');
                log('BaseDownloader åŠ è½½æˆåŠŸ');
            } else {
                results.push('âŒ BaseDownloader æœªåŠ è½½');
                log('BaseDownloader åŠ è½½å¤±è´¥', 'error');
            }

            // æ£€æŸ¥ ESP32SeriesDownloader
            if (typeof ESP32SeriesDownloader !== 'undefined') {
                results.push('âœ… ESP32SeriesDownloader å·²åŠ è½½');
                log('ESP32SeriesDownloader åŠ è½½æˆåŠŸ');
            } else {
                results.push('âŒ ESP32SeriesDownloader æœªåŠ è½½');
                log('ESP32SeriesDownloader åŠ è½½å¤±è´¥', 'error');
            }

            const allLoaded = results.every(r => r.includes('âœ…'));
            updateTestResult('loadingTest', results.join('<br>'), allLoaded ? 'success' : 'error');
            
            return allLoaded;
        }

        // 2. æ£€æŸ¥ç±»å®šä¹‰
        function checkClassDefinition() {
            log('å¼€å§‹æ£€æŸ¥ç±»å®šä¹‰...');
            
            try {
                if (typeof ESP32SeriesDownloader === 'function') {
                    // æ£€æŸ¥ç»§æ‰¿å…³ç³»
                    const instance = Object.create(ESP32SeriesDownloader.prototype);
                    const isExtended = instance instanceof BaseDownloader;
                    
                    if (isExtended) {
                        updateTestResult('classTest', 'âœ… ESP32SeriesDownloader æ­£ç¡®ç»§æ‰¿äº† BaseDownloader', 'success');
                        log('ç±»ç»§æ‰¿å…³ç³»æ­£ç¡®');
                        return true;
                    } else {
                        updateTestResult('classTest', 'âŒ ESP32SeriesDownloader æ²¡æœ‰æ­£ç¡®ç»§æ‰¿ BaseDownloader', 'error');
                        log('ç±»ç»§æ‰¿å…³ç³»é”™è¯¯', 'error');
                        return false;
                    }
                } else {
                    updateTestResult('classTest', 'âŒ ESP32SeriesDownloader ä¸æ˜¯ä¸€ä¸ªæ„é€ å‡½æ•°', 'error');
                    log('ESP32SeriesDownloader ä¸æ˜¯æ„é€ å‡½æ•°', 'error');
                    return false;
                }
            } catch (error) {
                updateTestResult('classTest', `âŒ æ£€æŸ¥ç±»å®šä¹‰æ—¶å‡ºé”™: ${error.message}`, 'error');
                log(`æ£€æŸ¥ç±»å®šä¹‰å¤±è´¥: ${error.message}`, 'error');
                return false;
            }
        }

        // 3. æµ‹è¯•å®ä¾‹åˆ›å»º
        function testInstance() {
            log('å¼€å§‹æµ‹è¯•å®ä¾‹åˆ›å»º...');
            
            try {
                // åˆ›å»ºæ¨¡æ‹Ÿä¸²å£
                const mockPort = {
                    readable: null,
                    writable: null
                };

                // åˆ›å»ºè°ƒè¯•å›è°ƒ
                const debugCallback = (level, message, data) => {
                    log(`[${level}] ${message}`, level);
                };

                // åˆ›å»ºå®ä¾‹
                testInstance = new ESP32SeriesDownloader(mockPort, debugCallback);
                
                updateTestResult('instanceTest', 'âœ… ESP32SeriesDownloader å®ä¾‹åˆ›å»ºæˆåŠŸ', 'success');
                log('å®ä¾‹åˆ›å»ºæˆåŠŸ');
                
                // å¯ç”¨æ–¹æ³•æµ‹è¯•æŒ‰é’®
                document.getElementById('methodBtn').disabled = false;
                
                return true;
            } catch (error) {
                updateTestResult('instanceTest', `âŒ å®ä¾‹åˆ›å»ºå¤±è´¥: ${error.message}`, 'error');
                log(`å®ä¾‹åˆ›å»ºå¤±è´¥: ${error.message}`, 'error');
                return false;
            }
        }

        // 4. æµ‹è¯•æ–¹æ³•
        function testMethods() {
            if (!testInstance) {
                log('è¯·å…ˆåˆ›å»ºå®ä¾‹', 'warning');
                return;
            }

            log('å¼€å§‹æµ‹è¯•æ–¹æ³•...');
            
            const methods = [
                'setDebugMode',
                'setProgressCallback', 
                'getChipName',
                'connect',
                'disconnect',
                'downloadFirmware',
                'getChipId',
                'getFlashId',
                'isConnected',
                'getDeviceStatus',
                'setBaudrate',
                'cleanup'
            ];

            const results = [];
            
            methods.forEach(methodName => {
                if (typeof testInstance[methodName] === 'function') {
                    results.push(`âœ… ${methodName}`);
                    log(`æ–¹æ³• ${methodName} å­˜åœ¨`);
                } else {
                    results.push(`âŒ ${methodName}`);
                    log(`æ–¹æ³• ${methodName} ä¸å­˜åœ¨`, 'error');
                }
            });

            const allExist = results.every(r => r.includes('âœ…'));
            updateTestResult('methodTest', results.join('<br>'), allExist ? 'success' : 'error');
            
            // æµ‹è¯•è°ƒè¯•æ¨¡å¼è®¾ç½®
            try {
                testInstance.setDebugMode(true);
                log('setDebugMode(true) è°ƒç”¨æˆåŠŸ');
                
                testInstance.setDebugMode(false);
                log('setDebugMode(false) è°ƒç”¨æˆåŠŸ');
            } catch (error) {
                log(`setDebugMode è°ƒç”¨å¤±è´¥: ${error.message}`, 'error');
            }
        }

        // 5. æµ‹è¯•ä¸²å£è¿æ¥ (éœ€è¦ç”¨æˆ·æˆæƒ)
        async function testSerialConnection() {
            if (!testInstance) {
                updateTestResult('serialTest', 'âŒ è¯·å…ˆåˆ›å»ºå®ä¾‹', 'error');
                return;
            }

            log('å¼€å§‹æµ‹è¯•ä¸²å£è¿æ¥...');
            updateTestResult('serialTest', 'ğŸ”„ æ­£åœ¨æµ‹è¯•ä¸²å£è¿æ¥...', 'info');

            try {
                // æ£€æŸ¥Web Serial APIæ”¯æŒ
                if (!navigator.serial) {
                    throw new Error('æµè§ˆå™¨ä¸æ”¯æŒWeb Serial API');
                }

                // è¯·æ±‚ä¸²å£æƒé™
                const port = await navigator.serial.requestPort();
                log('ä¸²å£æƒé™è·å–æˆåŠŸ');

                // åˆ›å»ºçœŸå®çš„ä¸‹è½½å™¨å®ä¾‹
                const realDownloader = new ESP32SeriesDownloader(port, (level, message, data) => {
                    log(`[${level}] ${message}`, level);
                });

                // å°è¯•è¿æ¥
                const connected = await realDownloader.connect();
                
                if (connected) {
                    updateTestResult('serialTest', 'âœ… ä¸²å£è¿æ¥æˆåŠŸï¼ŒèŠ¯ç‰‡æ£€æµ‹æ­£å¸¸', 'success');
                    log('ä¸²å£è¿æ¥å’ŒèŠ¯ç‰‡æ£€æµ‹æˆåŠŸ');
                    
                    // è·å–è®¾å¤‡çŠ¶æ€
                    const status = realDownloader.getDeviceStatus();
                    log(`è®¾å¤‡çŠ¶æ€: ${JSON.stringify(status)}`);
                    
                    // æ–­å¼€è¿æ¥
                    await realDownloader.disconnect();
                    log('å·²æ–­å¼€è¿æ¥');
                } else {
                    updateTestResult('serialTest', 'âŒ ä¸²å£è¿æ¥å¤±è´¥', 'error');
                    log('ä¸²å£è¿æ¥å¤±è´¥', 'error');
                }

            } catch (error) {
                if (error.message.includes('No port selected')) {
                    updateTestResult('serialTest', 'âš ï¸ ç”¨æˆ·å–æ¶ˆäº†ä¸²å£é€‰æ‹©', 'warning');
                    log('ç”¨æˆ·å–æ¶ˆäº†ä¸²å£é€‰æ‹©', 'warning');
                } else {
                    updateTestResult('serialTest', `âŒ ä¸²å£è¿æ¥æµ‹è¯•å¤±è´¥: ${error.message}`, 'error');
                    log(`ä¸²å£è¿æ¥æµ‹è¯•å¤±è´¥: ${error.message}`, 'error');
                }
            }
        }

        // é¡µé¢åŠ è½½å®Œæˆåæ‰§è¡Œæµ‹è¯•
        window.addEventListener('load', function() {
            log('é¡µé¢åŠ è½½å®Œæˆï¼Œå¼€å§‹è‡ªåŠ¨æµ‹è¯•...');
            
            setTimeout(() => {
                const depsOk = checkDependencies();
                if (depsOk) {
                    setTimeout(() => {
                        checkClassDefinition();
                    }, 500);
                }
            }, 1000);
        });
    </script>
</body>
</html> 