<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ESP32-Series集成测试</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
        }
        .test-section {
            margin: 20px 0;
            padding: 15px;
            border: 1px solid #ddd;
            border-radius: 8px;
        }
        .success { background-color: #d4edda; border-color: #c3e6cb; }
        .error { background-color: #f8d7da; border-color: #f5c6cb; }
        .info { background-color: #d1ecf1; border-color: #bee5eb; }
        .warning { background-color: #fff3cd; border-color: #ffeaa7; }
        button {
            padding: 10px 20px;
            margin: 5px;
            border: none;
            border-radius: 4px;
            background-color: #007bff;
            color: white;
            cursor: pointer;
        }
        button:hover { background-color: #0056b3; }
        button:disabled {
            background-color: #6c757d;
            cursor: not-allowed;
        }
        .log {
            background-color: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 4px;
            padding: 10px;
            margin: 10px 0;
            font-family: monospace;
            white-space: pre-wrap;
            max-height: 300px;
            overflow-y: auto;
        }
    </style>
</head>
<body>
    <h1>ESP32-Series 集成测试</h1>
    
    <div class="test-section" id="loadingTest">
        <h3>1. 依赖加载测试</h3>
        <div id="loadingResults">正在检查...</div>
    </div>

    <div class="test-section" id="classTest">
        <h3>2. 类定义测试</h3>
        <div id="classResults">正在检查...</div>
    </div>

    <div class="test-section" id="instanceTest">
        <h3>3. 实例创建测试</h3>
        <button onclick="testInstance()">创建ESP32SeriesDownloader实例</button>
        <div id="instanceResults"></div>
    </div>

    <div class="test-section" id="methodTest">
        <h3>4. 方法测试</h3>
        <button onclick="testMethods()" id="methodBtn" disabled>测试所有方法</button>
        <div id="methodResults"></div>
    </div>

    <div class="test-section" id="serialTest">
        <h3>5. 串口连接测试 (需要真实设备)</h3>
        <button onclick="testSerialConnection()" id="serialBtn">测试串口连接</button>
        <div id="serialResults"></div>
    </div>

    <div class="test-section">
        <h3>测试日志</h3>
        <button onclick="clearLog()">清空日志</button>
        <div class="log" id="testLog"></div>
    </div>

    <!-- 引入依赖 -->
    <script type="module">
        import { ESPLoader } from './third_party/esptool-js.bundle.js';
        window.ESPLoader = ESPLoader;
        console.log('✅ ESPLoader 已加载到全局变量');
    </script>
    <script src="downloaders/base-downloader.js"></script>
    <script src="downloaders/esp32-series-downloader.js"></script>

    <script>
        let testInstance = null;
        let testLog = [];

        function log(message, type = 'info') {
            const timestamp = new Date().toLocaleTimeString();
            const logMessage = `[${timestamp}] [${type.toUpperCase()}] ${message}`;
            testLog.push(logMessage);
            
            const logElement = document.getElementById('testLog');
            logElement.textContent = testLog.join('\n');
            logElement.scrollTop = logElement.scrollHeight;
            
            console.log(logMessage);
        }

        function clearLog() {
            testLog = [];
            document.getElementById('testLog').textContent = '';
        }

        function updateTestResult(sectionId, content, status = 'info') {
            const section = document.getElementById(sectionId);
            const resultsDiv = section.querySelector('div:last-child');
            resultsDiv.innerHTML = content;
            
            // 更新样式
            section.className = 'test-section ' + status;
        }

        // 1. 检查依赖加载
        function checkDependencies() {
            log('开始检查依赖加载...');
            
            const results = [];
            
            // 检查 esptool-js
            if (typeof ESPLoader !== 'undefined') {
                results.push('✅ esptool-js (ESPLoader) 已加载');
                log('esptool-js 加载成功');
            } else {
                results.push('❌ esptool-js (ESPLoader) 未加载');
                log('esptool-js 加载失败', 'error');
            }

            // 检查 BaseDownloader
            if (typeof BaseDownloader !== 'undefined') {
                results.push('✅ BaseDownloader 已加载');
                log('BaseDownloader 加载成功');
            } else {
                results.push('❌ BaseDownloader 未加载');
                log('BaseDownloader 加载失败', 'error');
            }

            // 检查 ESP32SeriesDownloader
            if (typeof ESP32SeriesDownloader !== 'undefined') {
                results.push('✅ ESP32SeriesDownloader 已加载');
                log('ESP32SeriesDownloader 加载成功');
            } else {
                results.push('❌ ESP32SeriesDownloader 未加载');
                log('ESP32SeriesDownloader 加载失败', 'error');
            }

            const allLoaded = results.every(r => r.includes('✅'));
            updateTestResult('loadingTest', results.join('<br>'), allLoaded ? 'success' : 'error');
            
            return allLoaded;
        }

        // 2. 检查类定义
        function checkClassDefinition() {
            log('开始检查类定义...');
            
            try {
                if (typeof ESP32SeriesDownloader === 'function') {
                    // 检查继承关系
                    const instance = Object.create(ESP32SeriesDownloader.prototype);
                    const isExtended = instance instanceof BaseDownloader;
                    
                    if (isExtended) {
                        updateTestResult('classTest', '✅ ESP32SeriesDownloader 正确继承了 BaseDownloader', 'success');
                        log('类继承关系正确');
                        return true;
                    } else {
                        updateTestResult('classTest', '❌ ESP32SeriesDownloader 没有正确继承 BaseDownloader', 'error');
                        log('类继承关系错误', 'error');
                        return false;
                    }
                } else {
                    updateTestResult('classTest', '❌ ESP32SeriesDownloader 不是一个构造函数', 'error');
                    log('ESP32SeriesDownloader 不是构造函数', 'error');
                    return false;
                }
            } catch (error) {
                updateTestResult('classTest', `❌ 检查类定义时出错: ${error.message}`, 'error');
                log(`检查类定义失败: ${error.message}`, 'error');
                return false;
            }
        }

        // 3. 测试实例创建
        function testInstance() {
            log('开始测试实例创建...');
            
            try {
                // 创建模拟串口
                const mockPort = {
                    readable: null,
                    writable: null
                };

                // 创建调试回调
                const debugCallback = (level, message, data) => {
                    log(`[${level}] ${message}`, level);
                };

                // 创建实例
                testInstance = new ESP32SeriesDownloader(mockPort, debugCallback);
                
                updateTestResult('instanceTest', '✅ ESP32SeriesDownloader 实例创建成功', 'success');
                log('实例创建成功');
                
                // 启用方法测试按钮
                document.getElementById('methodBtn').disabled = false;
                
                return true;
            } catch (error) {
                updateTestResult('instanceTest', `❌ 实例创建失败: ${error.message}`, 'error');
                log(`实例创建失败: ${error.message}`, 'error');
                return false;
            }
        }

        // 4. 测试方法
        function testMethods() {
            if (!testInstance) {
                log('请先创建实例', 'warning');
                return;
            }

            log('开始测试方法...');
            
            const methods = [
                'setDebugMode',
                'setProgressCallback', 
                'getChipName',
                'connect',
                'disconnect',
                'downloadFirmware',
                'getChipId',
                'getFlashId',
                'isConnected',
                'getDeviceStatus',
                'setBaudrate',
                'cleanup'
            ];

            const results = [];
            
            methods.forEach(methodName => {
                if (typeof testInstance[methodName] === 'function') {
                    results.push(`✅ ${methodName}`);
                    log(`方法 ${methodName} 存在`);
                } else {
                    results.push(`❌ ${methodName}`);
                    log(`方法 ${methodName} 不存在`, 'error');
                }
            });

            const allExist = results.every(r => r.includes('✅'));
            updateTestResult('methodTest', results.join('<br>'), allExist ? 'success' : 'error');
            
            // 测试调试模式设置
            try {
                testInstance.setDebugMode(true);
                log('setDebugMode(true) 调用成功');
                
                testInstance.setDebugMode(false);
                log('setDebugMode(false) 调用成功');
            } catch (error) {
                log(`setDebugMode 调用失败: ${error.message}`, 'error');
            }
        }

        // 5. 测试串口连接 (需要用户授权)
        async function testSerialConnection() {
            if (!testInstance) {
                updateTestResult('serialTest', '❌ 请先创建实例', 'error');
                return;
            }

            log('开始测试串口连接...');
            updateTestResult('serialTest', '🔄 正在测试串口连接...', 'info');

            try {
                // 检查Web Serial API支持
                if (!navigator.serial) {
                    throw new Error('浏览器不支持Web Serial API');
                }

                // 请求串口权限
                const port = await navigator.serial.requestPort();
                log('串口权限获取成功');

                // 创建真实的下载器实例
                const realDownloader = new ESP32SeriesDownloader(port, (level, message, data) => {
                    log(`[${level}] ${message}`, level);
                });

                // 尝试连接
                const connected = await realDownloader.connect();
                
                if (connected) {
                    updateTestResult('serialTest', '✅ 串口连接成功，芯片检测正常', 'success');
                    log('串口连接和芯片检测成功');
                    
                    // 获取设备状态
                    const status = realDownloader.getDeviceStatus();
                    log(`设备状态: ${JSON.stringify(status)}`);
                    
                    // 断开连接
                    await realDownloader.disconnect();
                    log('已断开连接');
                } else {
                    updateTestResult('serialTest', '❌ 串口连接失败', 'error');
                    log('串口连接失败', 'error');
                }

            } catch (error) {
                if (error.message.includes('No port selected')) {
                    updateTestResult('serialTest', '⚠️ 用户取消了串口选择', 'warning');
                    log('用户取消了串口选择', 'warning');
                } else {
                    updateTestResult('serialTest', `❌ 串口连接测试失败: ${error.message}`, 'error');
                    log(`串口连接测试失败: ${error.message}`, 'error');
                }
            }
        }

        // 页面加载完成后执行测试
        window.addEventListener('load', function() {
            log('页面加载完成，开始自动测试...');
            
            setTimeout(() => {
                const depsOk = checkDependencies();
                if (depsOk) {
                    setTimeout(() => {
                        checkClassDefinition();
                    }, 500);
                }
            }, 1000);
        });
    </script>
</body>
</html> 