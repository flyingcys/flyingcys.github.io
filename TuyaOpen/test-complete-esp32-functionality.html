<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ESP32 å®Œæ•´åŠŸèƒ½æµ‹è¯• - å¯¹æ¯”esptool-js</title>
    <style>
        body {
            font-family: 'Segoe UI', Arial, sans-serif;
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
            background: #f5f7fa;
        }
        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            border-radius: 12px;
            margin-bottom: 30px;
            text-align: center;
        }
        .container {
            background: white;
            border-radius: 12px;
            padding: 25px;
            margin-bottom: 25px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        .test-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }
        .test-card {
            border: 2px solid #e1e5e9;
            border-radius: 8px;
            padding: 20px;
            background: #f8f9fa;
        }
        .test-card.success { border-color: #28a745; background: #d4edda; }
        .test-card.error { border-color: #dc3545; background: #f8d7da; }
        .test-card.running { border-color: #007bff; background: #d1ecf1; }
        
        button {
            background: #007bff;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 6px;
            cursor: pointer;
            margin: 5px;
            font-size: 14px;
            transition: all 0.3s;
        }
        button:hover { background: #0056b3; transform: translateY(-1px); }
        button:disabled { background: #6c757d; cursor: not-allowed; transform: none; }
        button.success { background: #28a745; }
        button.error { background: #dc3545; }
        
        .status {
            margin: 15px 0;
            padding: 15px;
            border-radius: 8px;
            font-weight: bold;
        }
        .status.success { background: #d4edda; color: #155724; border: 2px solid #c3e6cb; }
        .status.error { background: #f8d7da; color: #721c24; border: 2px solid #f5c6cb; }
        .status.info { background: #d1ecf1; color: #0c5460; border: 2px solid #bee5eb; }
        
        .log {
            background: #1e1e1e;
            color: #00ff00;
            padding: 20px;
            border-radius: 8px;
            height: 400px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            white-space: pre-wrap;
            border: 2px solid #333;
        }
        
        .chip-info {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin: 20px 0;
        }
        .chip-info div {
            padding: 12px;
            background: #e9ecef;
            border-radius: 6px;
            border-left: 4px solid #007bff;
        }
        
        .progress-bar {
            width: 100%;
            height: 20px;
            background: #e9ecef;
            border-radius: 10px;
            overflow: hidden;
            margin: 10px 0;
        }
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #28a745, #20c997);
            width: 0%;
            transition: width 0.3s;
        }
        
        h2 {
            color: #2c3e50;
            border-bottom: 3px solid #3498db;
            padding-bottom: 10px;
            margin-bottom: 20px;
        }
        h3 {
            color: #34495e;
            margin: 15px 0 10px 0;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>ğŸš€ ESP32 å®Œæ•´åŠŸèƒ½æµ‹è¯•å¥—ä»¶</h1>
        <p>éªŒè¯ ESP32EsptoolJSWrapper vs esptool-js åŠŸèƒ½å®ç°</p>
    </div>
    
    <!-- è¿æ¥æ§åˆ¶é¢æ¿ -->
    <div class="container">
        <h2>ğŸ”Œ è®¾å¤‡è¿æ¥æ§åˆ¶</h2>
        <div class="test-grid">
            <div>
                <button id="connectBtn">è¿æ¥ESP32è®¾å¤‡</button>
                <button id="mockTestBtn">ğŸ§ª æ¨¡æ‹Ÿæµ‹è¯•ï¼ˆæ— è®¾å¤‡ï¼‰</button>
                <button id="disconnectBtn" disabled>æ–­å¼€è¿æ¥</button>
                <button id="detectChipBtn" disabled>é‡æ–°æ£€æµ‹èŠ¯ç‰‡</button>
            </div>
            <div>
                <div id="connectionStatus" class="status info">è¯·å…ˆè¿æ¥ESP32è®¾å¤‡</div>
            </div>
        </div>
        
        <div id="chipInfo" class="chip-info" style="display: none;">
            <div><strong>èŠ¯ç‰‡ç±»å‹:</strong> <span id="chipType">-</span></div>
            <div><strong>èŠ¯ç‰‡æè¿°:</strong> <span id="chipDesc">-</span></div>
            <div><strong>MACåœ°å€:</strong> <span id="chipMac">-</span></div>
            <div><strong>æ™¶æŒ¯é¢‘ç‡:</strong> <span id="chipFreq">-</span></div>
            <div><strong>Flashå¤§å°:</strong> <span id="chipFlash">-</span></div>
            <div><strong>èŠ¯ç‰‡ç‰¹æ€§:</strong> <span id="chipFeatures">-</span></div>
        </div>
    </div>

    <!-- æ ¸å¿ƒåŠŸèƒ½æµ‹è¯• -->
    <div class="container">
        <h2>âš™ï¸ æ ¸å¿ƒåŠŸèƒ½æµ‹è¯•</h2>
        <div class="test-grid">
            <div class="test-card" id="basicTest">
                <h3>åŸºç¡€é€šä¿¡æµ‹è¯•</h3>
                <button id="testBasicBtn" disabled>æµ‹è¯•åŸºç¡€é€šä¿¡</button>
                <p>æµ‹è¯•: sync(), readReg(), writeReg()</p>
            </div>
            
            <div class="test-card" id="dataTest">
                <h3>æ•°æ®è½¬æ¢æµ‹è¯•</h3>
                <button id="testDataBtn" disabled>æµ‹è¯•æ•°æ®è½¬æ¢</button>
                <p>æµ‹è¯•: æ‰€æœ‰æ•°æ®è½¬æ¢å·¥å…·æ–¹æ³•</p>
            </div>
            
            <div class="test-card" id="flashTest">
                <h3>Flashæ“ä½œæµ‹è¯•</h3>
                <button id="testFlashBtn" disabled>æµ‹è¯•Flashæ“ä½œ</button>
                <p>æµ‹è¯•: readFlashId(), flashMd5sum()</p>
            </div>
            
            <div class="test-card" id="resetTest">
                <h3>é‡ç½®ç­–ç•¥æµ‹è¯•</h3>
                <button id="testResetBtn" disabled>æµ‹è¯•é‡ç½®ç­–ç•¥</button>
                <p>æµ‹è¯•: 4ç§é‡ç½®ç­–ç•¥ç³»ç»Ÿ</p>
            </div>
        </div>
    </div>

    <!-- å¢å¼ºåŠŸèƒ½æµ‹è¯• -->
    <div class="container">
        <h2>ğŸ”¥ å¢å¼ºåŠŸèƒ½æµ‹è¯•</h2>
        <div class="test-grid">
            <div class="test-card" id="romTest">
                <h3>ROMç³»ç»Ÿå¢å¼º</h3>
                <button id="testRomBtn" disabled>æµ‹è¯•ROMåŠŸèƒ½</button>
                <p>æµ‹è¯•: eFuseè¯»å–, ç‰ˆæœ¬æ£€æµ‹, ç‰¹æ€§è¯†åˆ«</p>
            </div>
            
            <div class="test-card" id="terminalTest">
                <h3>ç»ˆç«¯æ¥å£æµ‹è¯•</h3>
                <button id="testTerminalBtn" disabled>æµ‹è¯•ç»ˆç«¯æ¥å£</button>
                <p>æµ‹è¯•: write(), info(), debug(), error()</p>
            </div>
            
            <div class="test-card" id="errorTest">
                <h3>é”™è¯¯å¤„ç†æµ‹è¯•</h3>
                <button id="testErrorBtn" disabled>æµ‹è¯•é”™è¯¯å¤„ç†</button>
                <p>æµ‹è¯•: å¼‚å¸¸åˆ†ç±», è‡ªåŠ¨æ¢å¤</p>
            </div>
            
            <div class="test-card" id="performanceTest">
                <h3>æ€§èƒ½åŸºå‡†æµ‹è¯•</h3>
                <button id="testPerformanceBtn" disabled>æ€§èƒ½æµ‹è¯•</button>
                <p>æµ‹è¯•: è¿æ¥é€Ÿåº¦, æ“ä½œæ€§èƒ½, é«˜çº§åŠŸèƒ½</p>
            </div>
        </div>
    </div>

    <!-- é—æ¼çš„æ ¸å¿ƒåŠŸèƒ½æµ‹è¯• -->
    <div class="container">
        <h2>ğŸ”§ é—æ¼åŠŸèƒ½è¡¥å……æµ‹è¯•</h2>
        <div class="test-grid">
            <div class="test-card" id="flashWriteTest">
                <h3>Flashå†™å…¥æ“ä½œæµ‹è¯•</h3>
                <button id="testFlashWriteBtn" disabled>æµ‹è¯•Flashå†™å…¥</button>
                <p>æµ‹è¯•: writeFlash(), flashBegin/Block/Finish()</p>
            </div>
            
            <div class="test-card" id="memoryTest">
                <h3>å†…å­˜æ“ä½œæµ‹è¯•</h3>
                <button id="testMemoryBtn" disabled>æµ‹è¯•å†…å­˜æ“ä½œ</button>
                <p>æµ‹è¯•: memBegin/Block/Finish()</p>
            </div>
            
            <div class="test-card" id="stubTest">
                <h3>StubåŠ è½½å™¨æµ‹è¯•</h3>
                <button id="testStubBtn" disabled>æµ‹è¯•StubåŠŸèƒ½</button>
                <p>æµ‹è¯•: runStub(), eraseFlash()</p>
            </div>
            
            <div class="test-card" id="advancedTest">
                <h3>é«˜çº§åŠŸèƒ½æµ‹è¯•</h3>
                <button id="testAdvancedBtn" disabled>æµ‹è¯•é«˜çº§åŠŸèƒ½</button>
                <p>æµ‹è¯•: _connectAttempt(), å‹ç¼©Flashæ“ä½œ</p>
            </div>
        </div>
    </div>

    <!-- æµ‹è¯•è¿›åº¦ -->
    <div class="container">
        <h2>ğŸ“Š æµ‹è¯•è¿›åº¦</h2>
        <div class="progress-bar">
            <div class="progress-fill" id="progressFill"></div>
        </div>
        <p id="progressText">ç­‰å¾…å¼€å§‹æµ‹è¯• (0/8)</p>
    </div>

    <!-- è°ƒè¯•æ—¥å¿— -->
    <div class="container">
        <h2>ğŸ“ è°ƒè¯•æ—¥å¿—</h2>
        <div id="debugLog" class="log">ç­‰å¾…è¿æ¥ESP32è®¾å¤‡...</div>
        <button id="clearLogBtn">æ¸…ç©ºæ—¥å¿—</button>
        <button id="exportLogBtn">å¯¼å‡ºæ—¥å¿—</button>
    </div>

    <!-- åŠ è½½ä¾èµ– -->
    <script src="third_party/esptool-js-umd.bundle.js"></script>
    <script src="downloaders/base-downloader.js"></script>
    <script src="downloaders/esp32/esp32-esptool-js-wrapper.js"></script>

    <script>
        // === è¯¦ç»†è°ƒè¯•ä¿¡æ¯å¼€å§‹ ===
        console.log('ğŸ” [DEBUG] Script starting...');
        console.log('ğŸ” [DEBUG] navigator.serial available:', !!navigator.serial);
        console.log('ğŸ” [DEBUG] window.ESP32EsptoolJSWrapper available:', !!window.ESP32EsptoolJSWrapper);
        console.log('ğŸ” [DEBUG] window.BaseDownloader available:', !!window.BaseDownloader);
        
        // ========== å®Œæ•´çš„esptool-jsè°ƒè¯•ç³»ç»Ÿ ==========
        console.log('ğŸ” [DEBUG] ========== esptool-js å®Œæ•´è°ƒè¯•å¼€å§‹ ==========');
        
        // 1. åŸºç¡€åº“æ£€æŸ¥
        console.log('ğŸ” [DEBUG] window.esptooljs exists:', !!window.esptooljs);
        if (window.esptooljs) {
            console.log('ğŸ” [DEBUG] esptooljs type:', typeof window.esptooljs);
            console.log('ğŸ” [DEBUG] esptooljs keys:', Object.keys(window.esptooljs));
            
            // 2. æ ¸å¿ƒç±»æ£€æŸ¥
            const coreClasses = ['ESPLoader', 'Transport', 'ClassicReset', 'HardReset', 'UsbJtagSerialReset', 'CustomReset'];
            coreClasses.forEach(className => {
                const classRef = window.esptooljs[className];
                console.log(`ğŸ” [DEBUG] ${className}:`, {
                    exists: !!classRef,
                    type: typeof classRef,
                    isConstructor: typeof classRef === 'function',
                    prototype: classRef?.prototype ? Object.getOwnPropertyNames(classRef.prototype) : null
                });
            });
            
            // 3. å·¥å…·å‡½æ•°æ£€æŸ¥
            const utilFunctions = ['validateCustomResetStringSequence', 'inflate', 'deflate'];
            utilFunctions.forEach(funcName => {
                console.log(`ğŸ” [DEBUG] ${funcName}:`, {
                    exists: !!window.esptooljs[funcName],
                    type: typeof window.esptooljs[funcName]
                });
            });
            
            // 4. å°è¯•æ„é€ ESPLoaderæµ‹è¯•
            try {
                console.log('ğŸ” [DEBUG] æµ‹è¯• ESPLoader æ„é€ ...');
                                 const mockTransport = {
                     device: null,
                     baudrate: 115200,
                     connect: async () => {},
                     disconnect: async () => {},
                     write: async () => {},
                     read: async function*() {},
                     setRTS: async () => {},
                     setDTR: async () => {},
                     getInfo: () => "Mock Serial Port",
                     waitForUnlock: async () => {},
                     slip_writer: async () => {},
                     slip_reader: async function*() {},
                     checksum: () => 0,
                     trace: false,
                     traceLog: []
                 };
                
                const testLoader = new window.esptooljs.ESPLoader({
                    transport: mockTransport,
                    baudrate: 115200,
                    terminal: {
                        clean: () => {},
                        writeLine: (data) => console.log('[MOCK]', data),
                        write: (data) => console.log('[MOCK]', data)
                    },
                    debugLogging: true
                });
                
                console.log('âœ… [DEBUG] ESPLoader æ„é€ æˆåŠŸ:', testLoader);
                console.log('ğŸ” [DEBUG] ESPLoader methods:', Object.getOwnPropertyNames(Object.getPrototypeOf(testLoader)));
                
            } catch (error) {
                console.error('âŒ [DEBUG] ESPLoader æ„é€ å¤±è´¥:', error);
                console.error('âŒ [DEBUG] Error stack:', error.stack);
            }
            
        } else {
            console.error('âŒ [DEBUG] esptool-js æœªåŠ è½½ï¼');
        }
        
        console.log('ğŸ” [DEBUG] ========== esptool-js è°ƒè¯•ç»“æŸ ==========');
        
        // æ£€æŸ¥æ‰€æœ‰ä¾èµ–
        const requiredGlobals = ['ESP32EsptoolJSWrapper', 'BaseDownloader'];
        requiredGlobals.forEach(name => {
            if (window[name]) {
                console.log(`âœ… [DEBUG] ${name} loaded successfully`);
                console.log(`ğŸ” [DEBUG] ${name} type:`, typeof window[name]);
                if (typeof window[name] === 'function') {
                    console.log(`ğŸ” [DEBUG] ${name} prototype:`, window[name].prototype);
                }
            } else {
                console.error(`âŒ [DEBUG] ${name} not found in window`);
            }
        });
        
        class ESP32CompleteTester {
            constructor() {
                console.log('ğŸ” [DEBUG] ESP32CompleteTester constructor called');
                this.downloader = null;
                this.serialPort = null;
                        this.testResults = {};
        this.totalTests = 12; // å¢åŠ 4ä¸ªæ–°æµ‹è¯•
        this.completedTests = 0;
                this.isConnecting = false; // è¿æ¥çŠ¶æ€æ ‡è®°
                
                // æ·»åŠ é”™è¯¯æ•è·
                try {
                    console.log('ğŸ” [DEBUG] Calling initializeEventListeners...');
                    this.initializeEventListeners();
                    console.log('âœ… [DEBUG] Event listeners initialized successfully');
                } catch (error) {
                    console.error('âŒ [DEBUG] Failed to initialize event listeners:', error);
                    console.error('âŒ [DEBUG] Error stack:', error.stack);
                }
            }

            initializeEventListeners() {
                console.log('ğŸ” [DEBUG] initializeEventListeners started');
                
                // æ£€æŸ¥æ‰€æœ‰æŒ‰é’®å…ƒç´ 
                const buttonIds = ['connectBtn', 'disconnectBtn', 'detectChipBtn', 'testBasicBtn', 'testDataBtn', 'testFlashBtn', 'testResetBtn', 'testRomBtn', 'testTerminalBtn', 'testErrorBtn', 'testPerformanceBtn', 'clearLogBtn', 'exportLogBtn'];
                buttonIds.forEach(id => {
                    const element = document.getElementById(id);
                    if (element) {
                        console.log(`âœ… [DEBUG] Found element: ${id}`);
                    } else {
                        console.error(`âŒ [DEBUG] Element not found: ${id}`);
                    }
                });
                
                // è¿æ¥æ§åˆ¶
                try {
                    console.log('ğŸ” [DEBUG] Setting up connect button...');
                    document.getElementById('connectBtn').onclick = () => {
                        console.log('ğŸ” [DEBUG] Connect button clicked');
                        this.connect();
                    };
                    console.log('âœ… [DEBUG] Connect button setup complete');
                    
                    // æ¨¡æ‹Ÿæµ‹è¯•æŒ‰é’®
                    document.getElementById('mockTestBtn').onclick = () => {
                        console.log('ğŸ” [DEBUG] Mock test button clicked');
                        this.runMockTest();
                    };
                    console.log('âœ… [DEBUG] Mock test button setup complete');
                    
                    console.log('ğŸ” [DEBUG] Setting up disconnect button...');
                    document.getElementById('disconnectBtn').onclick = () => {
                        console.log('ğŸ” [DEBUG] Disconnect button clicked');
                        this.disconnect();
                    };
                    console.log('âœ… [DEBUG] Disconnect button setup complete');
                    
                    console.log('ğŸ” [DEBUG] Setting up detect chip button...');
                    document.getElementById('detectChipBtn').onclick = () => {
                        console.log('ğŸ” [DEBUG] Detect chip button clicked');
                        this.detectChip();
                    };
                    console.log('âœ… [DEBUG] Detect chip button setup complete');
                } catch (error) {
                    console.error('âŒ [DEBUG] Error setting up connection buttons:', error);
                }
                
                // åŠŸèƒ½æµ‹è¯•
                try {
                    console.log('ğŸ” [DEBUG] Setting up test buttons...');
                    document.getElementById('testBasicBtn').onclick = () => {
                        console.log('ğŸ” [DEBUG] Basic test button clicked');
                        this.testBasicCommunication();
                    };
                    document.getElementById('testDataBtn').onclick = () => {
                        console.log('ğŸ” [DEBUG] Data test button clicked');
                        this.testDataConversion();
                    };
                    document.getElementById('testFlashBtn').onclick = () => {
                        console.log('ğŸ” [DEBUG] Flash test button clicked');
                        this.testFlashOperations();
                    };
                    document.getElementById('testResetBtn').onclick = () => {
                        console.log('ğŸ” [DEBUG] Reset test button clicked');
                        this.testResetStrategies();
                    };
                    document.getElementById('testRomBtn').onclick = () => {
                        console.log('ğŸ” [DEBUG] ROM test button clicked');
                        this.testROMEnhancements();
                    };
                    document.getElementById('testTerminalBtn').onclick = () => {
                        console.log('ğŸ” [DEBUG] Terminal test button clicked');
                        this.testTerminalInterface();
                    };
                    document.getElementById('testErrorBtn').onclick = () => {
                        console.log('ğŸ” [DEBUG] Error test button clicked');
                        this.testErrorHandling();
                    };
                    document.getElementById('testPerformanceBtn').onclick = () => {
                        console.log('ğŸ” [DEBUG] Performance test button clicked');
                        this.testPerformanceBenchmark();
                    };
                    
                    // æ–°å¢çš„é—æ¼åŠŸèƒ½æµ‹è¯•æŒ‰é’®
                    document.getElementById('testFlashWriteBtn').onclick = () => {
                        console.log('ğŸ” [DEBUG] Flash write test button clicked');
                        this.testFlashWriteOperations();
                    };
                    document.getElementById('testMemoryBtn').onclick = () => {
                        console.log('ğŸ” [DEBUG] Memory test button clicked');
                        this.testMemoryOperations();
                    };
                    document.getElementById('testStubBtn').onclick = () => {
                        console.log('ğŸ” [DEBUG] Stub test button clicked');
                        this.testStubLoader();
                    };
                    document.getElementById('testAdvancedBtn').onclick = () => {
                        console.log('ğŸ” [DEBUG] Advanced test button clicked');
                        this.testAdvancedFeatures();
                    };
                    console.log('âœ… [DEBUG] Test buttons setup complete');
                } catch (error) {
                    console.error('âŒ [DEBUG] Error setting up test buttons:', error);
                }
                
                // æ—¥å¿—æ§åˆ¶
                try {
                    console.log('ğŸ” [DEBUG] Setting up log control buttons...');
                    document.getElementById('clearLogBtn').onclick = () => {
                        console.log('ğŸ” [DEBUG] Clear log button clicked');
                        this.clearLog();
                    };
                    document.getElementById('exportLogBtn').onclick = () => {
                        console.log('ğŸ” [DEBUG] Export log button clicked');
                        this.exportLog();
                    };
                    console.log('âœ… [DEBUG] Log control buttons setup complete');
                } catch (error) {
                    console.error('âŒ [DEBUG] Error setting up log control buttons:', error);
                }
            }

            log(message, type = 'info') {
                const timestamp = new Date().toLocaleTimeString();
                const logElement = document.getElementById('debugLog');
                const typeMap = {
                    'error': 'âŒ [ERROR]',
                    'success': 'âœ… [SUCCESS]',
                    'debug': 'ğŸ” [DEBUG]',
                    'info': 'â„¹ï¸ [INFO]',
                    'warning': 'âš ï¸ [WARNING]'
                };
                const prefix = typeMap[type] || 'â„¹ï¸ [INFO]';
                logElement.textContent += `[${timestamp}] ${prefix} ${message}\n`;
                logElement.scrollTop = logElement.scrollHeight;
                console.log(`${prefix} ${message}`);
            }

            updateStatus(message, type = 'info') {
                const statusElement = document.getElementById('connectionStatus');
                statusElement.textContent = message;
                statusElement.className = `status ${type}`;
            }

            updateTestCard(cardId, status) {
                const card = document.getElementById(cardId);
                card.className = `test-card ${status}`;
                this.testResults[cardId] = status;
                this.updateProgress();
            }

            updateProgress() {
                this.completedTests = Object.keys(this.testResults).length;
                const percentage = (this.completedTests / this.totalTests) * 100;
                document.getElementById('progressFill').style.width = `${percentage}%`;
                document.getElementById('progressText').textContent = 
                    `æµ‹è¯•è¿›åº¦: ${this.completedTests}/${this.totalTests} (${Math.round(percentage)}%)`;
            }

            async connect() {
                // é˜²é‡å¤ç‚¹å‡»ä¿æŠ¤
                const connectBtn = document.getElementById('connectBtn');
                if (connectBtn.disabled || this.isConnecting) {
                    this.log('è¿æ¥æ­£åœ¨è¿›è¡Œä¸­ï¼Œè¯·ç¨å€™...', 'warning');
                    return;
                }
                
                // è®¾ç½®è¿æ¥çŠ¶æ€æ ‡è®°
                this.isConnecting = true;
                connectBtn.disabled = true;
                connectBtn.textContent = 'è¿æ¥ä¸­...';
                
                try {
                    console.log('ğŸ” [DEBUG] connect() method called');
                    this.log('ä½¿ç”¨esptool-jsæ ‡å‡†è¿æ¥æµç¨‹', 'success');
                    this.updateStatus('æ­£åœ¨è¯·æ±‚ä¸²å£æƒé™...', 'info');
                    
                    // æ£€æŸ¥Web Serial APIæ”¯æŒ
                    if (!navigator.serial) {
                        throw new Error('æµè§ˆå™¨ä¸æ”¯æŒ Web Serial APIï¼Œè¯·ä½¿ç”¨ Chrome æˆ– Edge æµè§ˆå™¨');
                    }
                    console.log('âœ… [DEBUG] Web Serial API available');
                    
                    // æ£€æŸ¥esptool.jsæ˜¯å¦å¯ç”¨
                    if (!window.esptooljs) {
                        throw new Error('esptool.js æœªåŠ è½½ï¼Œè¯·æ£€æŸ¥æ–‡ä»¶è·¯å¾„');
                    }
                    console.log('âœ… [DEBUG] esptool.js available');
                    
                    // è¯·æ±‚ä¸²å£ - å¿…é¡»åœ¨ç”¨æˆ·äº¤äº’ä¸­ç›´æ¥è°ƒç”¨
                    console.log('ğŸ” [DEBUG] Requesting serial port...');
                    this.log('å¼€å§‹è¿æ¥ESP32è®¾å¤‡...', 'info');
                    
                    try {
                        this.serialPort = await navigator.serial.requestPort();
                        this.log('ä¸²å£é€‰æ‹©æˆåŠŸ', 'success');
                        console.log('âœ… [DEBUG] Serial port selected:', this.serialPort);
                    } catch (portError) {
                        if (portError.name === 'NotAllowedError') {
                            throw new Error('ç”¨æˆ·å–æ¶ˆäº†ä¸²å£é€‰æ‹©æˆ–æƒé™è¢«æ‹’ç»');
                        } else if (portError.message.includes('user gesture')) {
                            throw new Error('è¯·ç›´æ¥ç‚¹å‡»è¿æ¥æŒ‰é’®ï¼Œä¸è¦å¿«é€Ÿå¤šæ¬¡ç‚¹å‡»');
                        } else {
                            throw new Error(`ä¸²å£é€‰æ‹©å¤±è´¥: ${portError.message}`);
                        }
                    }
                    
                    // ä½¿ç”¨ESP32EsptoolJSWrapperæ ‡å‡†è¿æ¥æµç¨‹
                    console.log('ğŸ” [DEBUG] Creating ESP32EsptoolJSWrapper...');
                    
                    this.downloader = new ESP32EsptoolJSWrapper(this.serialPort, {
                        log: (msg) => this.log(`[esptool.js] ${msg}`, 'debug'),
                        debug: (msg) => this.log(`[esptool.js] ${msg}`, 'debug'),
                        error: (msg) => this.log(`[esptool.js] ${msg}`, 'error')
                    });
                    
                    this.log('ESP32EsptoolJSWrapperå®ä¾‹åˆ›å»ºæˆåŠŸ', 'success');
                    console.log('âœ… [DEBUG] ESP32EsptoolJSWrapper instance created:', this.downloader);
                    
                    // âœ… ä½¿ç”¨åŒ…è£…å™¨çš„æ ‡å‡†è¿æ¥æ–¹æ³•
                    const startTime = performance.now();
                    
                    this.log('ä½¿ç”¨åŒ…è£…å™¨connect()æ–¹æ³•è¿æ¥...', 'info');
                    await this.downloader.connect();
                    
                    // è·å–è¿æ¥åçš„èŠ¯ç‰‡å®ä¾‹
                    this.chip = this.downloader.detectedChip;
                    
                    const connectTime = performance.now() - startTime;
                    
                    if (this.chip) {
                        this.log(`è¿æ¥æˆåŠŸï¼æ£€æµ‹åˆ°èŠ¯ç‰‡: ${this.chip.CHIP_NAME}`, 'success');
                        this.log(`è¿æ¥ç”¨æ—¶: ${Math.round(connectTime)}ms`, 'info');
                        
                        this.updateStatus(`å·²è¿æ¥ - ${this.chip.CHIP_NAME}`, 'success');
                        this.enableTestButtons();
                        await this.updateChipInfo();
                    } else {
                        throw new Error('èŠ¯ç‰‡æ£€æµ‹å¤±è´¥');
                    }
                    
                } catch (error) {
                    this.log(`è¿æ¥å¤±è´¥: ${error.message}`, 'error');
                    this.updateStatus(`è¿æ¥å¤±è´¥: ${error.message}`, 'error');
                    console.error('è¿æ¥é”™è¯¯è¯¦æƒ…:', error);
                } finally {
                    // æ¢å¤æŒ‰é’®çŠ¶æ€
                    this.isConnecting = false;
                    connectBtn.disabled = false;
                    connectBtn.textContent = 'è¿æ¥ESP32è®¾å¤‡';
                }
            }

            async updateChipInfo() {
                try {
                    if (!this.chip) {
                        throw new Error('èŠ¯ç‰‡å®ä¾‹æœªåˆå§‹åŒ–');
                    }
                    
                    // âœ… ä½¿ç”¨esptool-jsæ ‡å‡†èŠ¯ç‰‡ä¿¡æ¯è·å–æ–¹æ³•
                    this.log('è·å–èŠ¯ç‰‡è¯¦ç»†ä¿¡æ¯...', 'debug');
                    const chipDesc = await this.chip.getChipDescription(this.downloader);
                    const chipFeatures = await this.chip.getChipFeatures(this.downloader);
                    const crystalFreq = await this.chip.getCrystalFreq(this.downloader);
                    const macAddress = await this.chip.readMac(this.downloader);
                    
                    // è·å–Flashå¤§å°
                    let flashSize = '-';
                    try {
                        const flashId = await this.downloader.readFlashId();
                        const detectedSize = await this.downloader.getFlashSize();
                        flashSize = detectedSize || '-';
                    } catch (e) {
                        this.log(`Flashå¤§å°æ£€æµ‹å¤±è´¥: ${e.message}`, 'warning');
                    }
                    
                    // æ›´æ–°UIæ˜¾ç¤º
                    document.getElementById('chipType').textContent = this.chip.CHIP_NAME || '-';
                    document.getElementById('chipDesc').textContent = chipDesc || '-';
                    document.getElementById('chipMac').textContent = macAddress || '-';
                    document.getElementById('chipFreq').textContent = crystalFreq ? `${crystalFreq}MHz` : '-';
                    document.getElementById('chipFlash').textContent = flashSize;
                    document.getElementById('chipFeatures').textContent = chipFeatures?.join(', ') || '-';
                    
                    document.getElementById('chipInfo').style.display = 'grid';
                    this.log('èŠ¯ç‰‡ä¿¡æ¯è·å–å®Œæˆ', 'success');
                    
                } catch (error) {
                    this.log(`è·å–èŠ¯ç‰‡ä¿¡æ¯å¤±è´¥: ${error.message}`, 'error');
                }
            }

            enableTestButtons() {
                const buttons = [
                    'testBasicBtn', 'testDataBtn', 'testFlashBtn', 'testResetBtn',
                    'testRomBtn', 'testTerminalBtn', 'testErrorBtn', 'testPerformanceBtn',
                    'testFlashWriteBtn', 'testMemoryBtn', 'testStubBtn', 'testAdvancedBtn',
                    'disconnectBtn', 'detectChipBtn'
                ];
                buttons.forEach(id => {
                    document.getElementById(id).disabled = false;
                });
                document.getElementById('connectBtn').disabled = true;
            }

            async detectChip() {
                if (!this.downloader) {
                    this.log('è¯·å…ˆè¿æ¥è®¾å¤‡', 'warning');
                    return;
                }
                
                try {
                    this.log('ä½¿ç”¨æ ‡å‡†detectChip()é‡æ–°æ£€æµ‹èŠ¯ç‰‡...', 'info');
                    // âœ… ä½¿ç”¨esptool-jsæ ‡å‡†èŠ¯ç‰‡æ£€æµ‹æ–¹æ³•
                    await this.downloader.detectChip('default_reset');
                    this.chip = this.downloader.chip;
                    await this.updateChipInfo();
                    this.log('èŠ¯ç‰‡é‡æ–°æ£€æµ‹å®Œæˆ', 'success');
                } catch (error) {
                    this.log(`èŠ¯ç‰‡æ£€æµ‹å¤±è´¥: ${error.message}`, 'error');
                }
            }

            async testBasicCommunication() {
                this.log('=== å¼€å§‹åŸºç¡€é€šä¿¡æµ‹è¯• ===', 'info');
                this.updateTestCard('basicTest', 'running');
                
                try {
                    // âœ… connect()æ–¹æ³•å·²ç»å®Œæˆäº†syncï¼Œä¸éœ€è¦é‡å¤æµ‹è¯•è¿æ¥çŠ¶æ€
                    this.log('æµ‹è¯•esptool-jsæä¾›çš„åŸºç¡€é€šä¿¡åŠŸèƒ½...', 'debug');
                    if (!this.chip) {
                        throw new Error('èŠ¯ç‰‡æœªè¿æ¥');
                    }
                    this.log('è¿æ¥çŠ¶æ€æ­£å¸¸ï¼Œå¼€å§‹é€šä¿¡æµ‹è¯•', 'success');
                    
                    // âœ… æµ‹è¯•esptool-jsæ ‡å‡†çš„åŒæ­¥åŠŸèƒ½
                    this.log('æµ‹è¯• sync() æ–¹æ³•...', 'debug');
                    const [syncResponse, syncData] = await this.downloader.sync();
                    this.log(`sync() å“åº”: ${syncResponse}, æ•°æ®é•¿åº¦: ${syncData.length}`, 'success');
                    
                    // âœ… æµ‹è¯•esptool-jsæ ‡å‡†çš„å¯„å­˜å™¨è¯»å–
                    this.log('æµ‹è¯• readReg() æ–¹æ³•...', 'debug');
                    const regValue = await this.downloader.readReg(this.downloader.CHIP_DETECT_MAGIC_REG_ADDR);
                    this.log(`è¯»å–èŠ¯ç‰‡æ£€æµ‹å¯„å­˜å™¨: 0x${regValue.toString(16)}`, 'success');
                    
                    // âœ… æµ‹è¯•esptool-jsæ ‡å‡†çš„å¯„å­˜å™¨å†™å…¥
                    this.log('æµ‹è¯• writeReg() æ–¹æ³•...', 'debug');
                    const testReg = 0x3ff42040; // GPIOè¾“å‡ºå¯„å­˜å™¨ï¼ˆç›¸å¯¹å®‰å…¨ï¼‰
                    const originalValue = await this.downloader.readReg(testReg);
                    const testValue = 0x12345678;
                    await this.downloader.writeReg(testReg, testValue);
                    const readBack = await this.downloader.readReg(testReg);
                    // æ¢å¤åŸå€¼
                    await this.downloader.writeReg(testReg, originalValue);
                    this.log(`writeReg() æµ‹è¯•é€šè¿‡: å†™å…¥0x${testValue.toString(16)}, è¯»å–0x${readBack.toString(16)}`, 'success');
                    
                    // âœ… æµ‹è¯•esptool-jsæä¾›çš„è¾“å…¥ç¼“å†²åŒºæ¸…ç†
                    this.log('æµ‹è¯• flushInput() æ–¹æ³•...', 'debug');
                    await this.downloader.flushInput();
                    this.log('flushInput() æ‰§è¡ŒæˆåŠŸ', 'success');
                    
                    this.updateTestCard('basicTest', 'success');
                    this.log('=== åŸºç¡€é€šä¿¡æµ‹è¯•å®Œæˆ ===', 'success');
                    
                } catch (error) {
                    this.log(`åŸºç¡€é€šä¿¡æµ‹è¯•å¤±è´¥: ${error.message}`, 'error');
                    this.updateTestCard('basicTest', 'error');
                }
            }

            async testDataConversion() {
                this.log('=== å¼€å§‹æ•°æ®è½¬æ¢æµ‹è¯• ===', 'info');
                this.updateTestCard('dataTest', 'running');
                
                try {
                    // âœ… æµ‹è¯•esptool-jsæä¾›çš„å®Œæ•´æ•°æ®è½¬æ¢æ–¹æ³•
                    this.log('æµ‹è¯•æ•´æ•°è½¬æ¢æ–¹æ³•...', 'debug');
                    const testInt = 0x12345678;
                    const intBytes = this.downloader._intToByteArray(testInt);
                    const backInt = this.downloader._byteArrayToInt(intBytes[0], intBytes[1], intBytes[2], intBytes[3]);
                    if (testInt !== backInt) throw new Error('æ•´æ•°è½¬æ¢å¤±è´¥');
                    this.log(`æ•´æ•°è½¬æ¢æµ‹è¯•: 0x${testInt.toString(16)} âœ“`, 'success');
                    
                    // âœ… æµ‹è¯•çŸ­æ•´æ•°è½¬æ¢
                    this.log('æµ‹è¯•çŸ­æ•´æ•°è½¬æ¢æ–¹æ³•...', 'debug');
                    const testShort = 0x1234;
                    const shortBytes = this.downloader._shortToBytearray(testShort);
                    const backShort = this.downloader._byteArrayToShort(shortBytes[0], shortBytes[1]);
                    if (testShort !== backShort) throw new Error('çŸ­æ•´æ•°è½¬æ¢å¤±è´¥');
                    this.log(`çŸ­æ•´æ•°è½¬æ¢æµ‹è¯•: 0x${testShort.toString(16)} âœ“`, 'success');
                    
                    // âœ… æµ‹è¯•æ•°ç»„åˆå¹¶åŠŸèƒ½
                    this.log('æµ‹è¯•æ•°ç»„åˆå¹¶æ–¹æ³•...', 'debug');
                    const arr1 = new Uint8Array([1, 2, 3]);
                    const arr2 = new Uint8Array([4, 5, 6]);
                    const combined = this.downloader._appendArray(arr1, arr2);
                    const expected = [1, 2, 3, 4, 5, 6];
                    if (!combined.every((val, i) => val === expected[i])) throw new Error('æ•°ç»„åˆå¹¶å¤±è´¥');
                    this.log('æ•°ç»„åˆå¹¶æµ‹è¯•é€šè¿‡ âœ“', 'success');
                    
                    // âœ… æµ‹è¯•ç¼“å†²åŒºåˆå¹¶åŠŸèƒ½
                    this.log('æµ‹è¯•ç¼“å†²åŒºåˆå¹¶æ–¹æ³•...', 'debug');
                    const buf1 = new ArrayBuffer(3);
                    const buf2 = new ArrayBuffer(3);
                    new Uint8Array(buf1).set([1, 2, 3]);
                    new Uint8Array(buf2).set([4, 5, 6]);
                    const combinedBuf = this.downloader._appendBuffer(buf1, buf2);
                    const combinedArray = new Uint8Array(combinedBuf);
                    if (!combinedArray.every((val, i) => val === expected[i])) throw new Error('ç¼“å†²åŒºåˆå¹¶å¤±è´¥');
                    this.log('ç¼“å†²åŒºåˆå¹¶æµ‹è¯•é€šè¿‡ âœ“', 'success');
                    
                    // âœ… æµ‹è¯•æ ¡éªŒå’Œè®¡ç®—
                    this.log('æµ‹è¯•æ ¡éªŒå’Œè®¡ç®—...', 'debug');
                    const testData = new Uint8Array([0x01, 0x02, 0x03, 0x04, 0xAB, 0xCD, 0xEF]);
                    const checksum = this.downloader.checksum(testData);
                    this.log(`æ ¡éªŒå’Œæµ‹è¯•: 0x${checksum.toString(16)} âœ“`, 'success');
                    
                    // âœ… æµ‹è¯•äºŒè¿›åˆ¶å­—ç¬¦ä¸²è½¬æ¢
                    this.log('æµ‹è¯•äºŒè¿›åˆ¶å­—ç¬¦ä¸²è½¬æ¢...', 'debug');
                    const binaryStr = this.downloader.ui8ToBstr(testData);
                    const backData = this.downloader.bstrToUi8(binaryStr);
                    if (!testData.every((val, i) => val === backData[i])) throw new Error('äºŒè¿›åˆ¶å­—ç¬¦ä¸²è½¬æ¢å¤±è´¥');
                    this.log('äºŒè¿›åˆ¶å­—ç¬¦ä¸²è½¬æ¢æµ‹è¯•é€šè¿‡ âœ“', 'success');
                    
                    // âœ… æµ‹è¯•åå…­è¿›åˆ¶è½¬æ¢
                    this.log('æµ‹è¯•åå…­è¿›åˆ¶è½¬æ¢...', 'debug');
                    const hexStr = this.downloader.toHex(testData);
                    this.log(`åå…­è¿›åˆ¶è½¬æ¢: ${hexStr} âœ“`, 'success');
                    
                    this.updateTestCard('dataTest', 'success');
                    this.log('=== æ•°æ®è½¬æ¢æµ‹è¯•å®Œæˆ ===', 'success');
                    
                } catch (error) {
                    this.log(`æ•°æ®è½¬æ¢æµ‹è¯•å¤±è´¥: ${error.message}`, 'error');
                    this.updateTestCard('dataTest', 'error');
                }
            }

            async testFlashOperations() {
                this.log('=== å¼€å§‹Flashæ“ä½œæµ‹è¯• ===', 'info');
                this.updateTestCard('flashTest', 'running');
                
                try {
                    // âœ… æµ‹è¯•Flash IDè¯»å–
                    this.log('æµ‹è¯• readFlashId()...', 'debug');
                    try {
                        const flashId = await this.downloader.readFlashId();
                        this.log(`Flash ID: 0x${flashId.toString(16)}`, 'success');
                    } catch (e) {
                        this.log(`Flash IDè¯»å–å¤±è´¥: ${e.message}`, 'warning');
                        this.log('è¿™å¯èƒ½æ˜¯æ­£å¸¸çš„ï¼ŒæŸäº›ESP32åœ¨ROMæ¨¡å¼ä¸‹ä¸æ”¯æŒFlash IDè¯»å–', 'info');
                    }
                    
                    // âœ… æµ‹è¯•ä¸“ç”¨Flash IDæ–¹æ³•
                    this.log('æµ‹è¯• flashId()...', 'debug');
                    try {
                        await this.downloader.flashId();
                        this.log('flashId() æ‰§è¡ŒæˆåŠŸ', 'success');
                    } catch (e) {
                        this.log(`flashId() æ‰§è¡Œå¤±è´¥: ${e.message}`, 'warning');
                    }
                    
                    // âœ… æµ‹è¯•Flashå¤§å°æ£€æµ‹
                    this.log('æµ‹è¯• getFlashSize()...', 'debug');
                    try {
                        const flashSize = await this.downloader.getFlashSize();
                        this.log(`Flashå¤§å°: ${flashSize || 'æœªæ£€æµ‹åˆ°'}`, 'success');
                    } catch (e) {
                        this.log(`Flashå¤§å°æ£€æµ‹å¤±è´¥: ${e.message}`, 'warning');
                    }
                    
                    // âœ… æµ‹è¯•Flashå¤§å°å‚æ•°è§£æ
                    this.log('æµ‹è¯• parseFlashSizeArg()...', 'debug');
                    const sizeTests = ['1MB', '2MB', '4MB', '8MB', '16MB'];
                    sizeTests.forEach(size => {
                        try {
                            const parsed = this.downloader.parseFlashSizeArg(size);
                            this.log(`${size} -> ${parsed} bytes`, 'debug');
                        } catch (e) {
                            this.log(`è§£æ${size}å¤±è´¥: ${e.message}`, 'warning');
                        }
                    });
                    
                    // âœ… æµ‹è¯•Flashå¤§å°å­—èŠ‚è½¬æ¢å‡½æ•°
                    this.log('æµ‹è¯• flashSizeBytes() å‡½æ•°...', 'debug');
                    const flashSizeTests = ['1MB', '2MB', '4MB'];
                    flashSizeTests.forEach(size => {
                        try {
                            const bytes = this.downloader.flashSizeBytes(size);
                            this.log(`flashSizeBytes(${size}) = ${bytes} bytes`, 'debug');
                        } catch (e) {
                            this.log(`flashSizeBytes(${size}) å¤±è´¥: ${e.message}`, 'warning');
                        }
                    });
                    
                    // âœ… æµ‹è¯•Flash SPIè¿æ¥
                    this.log('æµ‹è¯• flashSpiAttach()...', 'debug');
                    try {
                        await this.downloader.flashSpiAttach(0);
                        this.log('flashSpiAttach() æ‰§è¡ŒæˆåŠŸ', 'success');
                    } catch (e) {
                        this.log(`flashSpiAttach() å¤±è´¥: ${e.message}`, 'warning');
                    }
                    
                    // âœ… æµ‹è¯•æ—¶é—´è®¡ç®—ï¼ˆçœŸå®çš„esptool-jsæ–¹æ³•ï¼‰
                    this.log('æµ‹è¯• timeoutPerMb()...', 'debug');
                    const timeout = this.downloader.timeoutPerMb(30, 1024 * 1024);
                    this.log(`è¶…æ—¶è®¡ç®—: 30ç§’/MB * 1MB = ${timeout}ms`, 'debug');
                    
                    // âœ… æµ‹è¯•SPI Flashå‘½ä»¤æ‰§è¡Œ
                    this.log('æµ‹è¯• runSpiflashCommand()...', 'debug');
                    try {
                        // è¯»å–FlashçŠ¶æ€å¯„å­˜å™¨å‘½ä»¤ (0x05)
                        const statusData = new Uint8Array([]);
                        const status = await this.downloader.runSpiflashCommand(0x05, statusData, 8);
                        this.log(`FlashçŠ¶æ€å¯„å­˜å™¨: 0x${status.toString(16)}`, 'success');
                    } catch (e) {
                        this.log(`runSpiflashCommand() å¤±è´¥: ${e.message}`, 'warning');
                    }
                    
                    // âœ… æµ‹è¯•Flash MD5æ ¡éªŒï¼ˆæ–°å¢çš„esptool-jsæ–¹æ³•ï¼‰
                    this.log('æµ‹è¯• flashMd5sum()...', 'debug');
                    try {
                        // æµ‹è¯•ä¸€å°æ®µFlashåŒºåŸŸçš„MD5æ ¡éªŒ
                        const flashMd5 = await this.downloader.flashMd5sum(0x1000, 1024);
                        this.log(`Flash MD5æ ¡éªŒ: ${flashMd5}`, 'success');
                    } catch (e) {
                        this.log(`flashMd5sum() å¤±è´¥: ${e.message}`, 'warning');
                        this.log('è¿™å¯èƒ½æ˜¯æ­£å¸¸çš„ï¼ŒæŸäº›ESP32åœ¨ROMæ¨¡å¼ä¸‹ä¸æ”¯æŒFlash MD5', 'info');
                    }
                    
                    // âœ… æµ‹è¯•Flashè¯»å–åŠŸèƒ½ï¼ˆæ–°å¢æµ‹è¯•ï¼‰
                    this.log('æµ‹è¯•Flashè¯»å–èƒ½åŠ›...', 'debug');
                    try {
                        // æ³¨æ„ï¼šè¿™é‡Œåªæµ‹è¯•æ–¹æ³•æ˜¯å¦å­˜åœ¨ï¼Œä¸å®é™…è¯»å–å¤§é‡æ•°æ®
                        if (typeof this.downloader.readFlash === 'function') {
                            this.log('readFlash() æ–¹æ³•å¯ç”¨', 'success');
                        }
                        if (typeof this.downloader.ESP_READ_FLASH !== 'undefined') {
                            this.log(`ESP_READ_FLASH å¸¸é‡: 0x${this.downloader.ESP_READ_FLASH.toString(16)}`, 'debug');
                        }
                    } catch (e) {
                        this.log(`Flashè¯»å–åŠŸèƒ½æµ‹è¯•å¤±è´¥: ${e.message}`, 'warning');
                    }
                    
                    this.updateTestCard('flashTest', 'success');
                    this.log('=== Flashæ“ä½œæµ‹è¯•å®Œæˆ ===', 'success');
                    
                } catch (error) {
                    this.log(`Flashæ“ä½œæµ‹è¯•å¤±è´¥: ${error.message}`, 'error');
                    this.updateTestCard('flashTest', 'error');
                }
            }

            async testResetStrategies() {
                this.log('=== å¼€å§‹é‡ç½®ç­–ç•¥æµ‹è¯• ===', 'info');
                this.updateTestCard('resetTest', 'running');
                
                try {
                    // âœ… æµ‹è¯•esptool-jsé‡ç½®ç­–ç•¥æ„é€ å™¨
                    this.log('æµ‹è¯•esptool-jsé‡ç½®ç­–ç•¥æ„é€ å™¨...', 'debug');
                    
                    // ClassicReset æ„é€ å™¨
                    try {
                        if (typeof window.esptooljs.ClassicReset === 'function') {
                            this.log('ClassicReset æ„é€ å™¨å¯ç”¨ âœ“', 'success');
                        }
                    } catch (e) {
                        this.log(`ClassicReset æµ‹è¯•å¤±è´¥: ${e.message}`, 'warning');
                    }
                    
                    // HardReset æ„é€ å™¨
                    try {
                        if (typeof window.esptooljs.HardReset === 'function') {
                            this.log('HardReset æ„é€ å™¨å¯ç”¨ âœ“', 'success');
                        }
                    } catch (e) {
                        this.log(`HardReset æµ‹è¯•å¤±è´¥: ${e.message}`, 'warning');
                    }
                    
                    // UsbJtagSerialReset æ„é€ å™¨
                    try {
                        if (typeof window.esptooljs.UsbJtagSerialReset === 'function') {
                            this.log('UsbJtagSerialReset æ„é€ å™¨å¯ç”¨ âœ“', 'success');
                        }
                    } catch (e) {
                        this.log(`UsbJtagSerialReset æµ‹è¯•å¤±è´¥: ${e.message}`, 'warning');
                    }
                    
                    // CustomReset æ„é€ å™¨
                    try {
                        if (typeof window.esptooljs.CustomReset === 'function') {
                            this.log('CustomReset æ„é€ å™¨å¯ç”¨ âœ“', 'success');
                        }
                    } catch (e) {
                        this.log(`CustomReset æµ‹è¯•å¤±è´¥: ${e.message}`, 'warning');
                    }
                    
                    // æµ‹è¯•é‡ç½®ç­–ç•¥æ„é€ ï¼ˆä½¿ç”¨æ­£ç¡®çš„APIï¼‰
                    this.log('æµ‹è¯•é‡ç½®ç­–ç•¥æ„é€ ...', 'debug');
                    const strategies = ['default_reset', 'usb_jtag_serial_reset', 'hard_reset'];
                    strategies.forEach(strategy => {
                        try {
                            const resetStrategies = this.downloader.constructResetSequence(strategy);
                            this.log(`é‡ç½®ç­–ç•¥æ„é€ æˆåŠŸ: ${strategy} -> ${resetStrategies.length} ç§ç­–ç•¥`, 'success');
                        } catch (e) {
                            this.log(`é‡ç½®ç­–ç•¥æ„é€ å¤±è´¥: ${strategy} - ${e.message}`, 'warning');
                        }
                    });
                    
                    // æµ‹è¯•è‡ªå®šä¹‰é‡ç½®åºåˆ—éªŒè¯ï¼ˆä½¿ç”¨å…¨å±€å‡½æ•°ï¼‰
                    this.log('æµ‹è¯•è‡ªå®šä¹‰é‡ç½®åºåˆ—éªŒè¯...', 'debug');
                    const validSequences = [
                        "D0|R1|W100|D1|R0|W50|D0",
                        "R0|W50|R1|W50|R0",
                        "D1|W100|D0"
                    ];
                    
                    validSequences.forEach(seq => {
                        try {
                            // âœ… ä½¿ç”¨esptool-jsçš„validateCustomResetStringSequenceæ–¹æ³•
                            const isValid = window.esptooljs.validateCustomResetStringSequence(seq);
                            if (!isValid) throw new Error(`åºåˆ—éªŒè¯å¤±è´¥: ${seq}`);
                            this.log(`åºåˆ—éªŒè¯é€šè¿‡: ${seq} âœ“`, 'success');
                        } catch (e) {
                            this.log(`åºåˆ—éªŒè¯å¤±è´¥: ${seq} - ${e.message}`, 'warning');
                        }
                    });
                    
                    this.updateTestCard('resetTest', 'success');
                    this.log('=== é‡ç½®ç­–ç•¥æµ‹è¯•å®Œæˆ ===', 'success');
                    
                } catch (error) {
                    this.log(`é‡ç½®ç­–ç•¥æµ‹è¯•å¤±è´¥: ${error.message}`, 'error');
                    this.updateTestCard('resetTest', 'error');
                }
            }

            async testROMEnhancements() {
                this.log('=== å¼€å§‹ROMç³»ç»Ÿå¢å¼ºæµ‹è¯• ===', 'info');
                this.updateTestCard('romTest', 'running');
                
                try {
                    if (!this.chip) {
                        throw new Error('ROMå®ä¾‹æœªåˆå§‹åŒ–');
                    }
                    
                    // æµ‹è¯•èŠ¯ç‰‡æè¿°
                    this.log('æµ‹è¯• getChipDescription()...', 'debug');
                    const description = await this.chip.getChipDescription(this.downloader);
                    this.log(`èŠ¯ç‰‡æè¿°: ${description}`, 'success');
                    
                    // æµ‹è¯•èŠ¯ç‰‡ç‰¹æ€§
                    this.log('æµ‹è¯• getChipFeatures()...', 'debug');
                    const features = await this.chip.getChipFeatures(this.downloader);
                    this.log(`èŠ¯ç‰‡ç‰¹æ€§: ${features.join(', ')}`, 'success');
                    
                    // æµ‹è¯•æ™¶æŒ¯é¢‘ç‡
                    this.log('æµ‹è¯• getCrystalFreq()...', 'debug');
                    const crystalFreq = await this.chip.getCrystalFreq(this.downloader);
                    this.log(`æ™¶æŒ¯é¢‘ç‡: ${crystalFreq}MHz`, 'success');
                    
                    // æµ‹è¯•MACåœ°å€è¯»å–
                    this.log('æµ‹è¯• readMac()...', 'debug');
                    const macAddress = await this.chip.readMac(this.downloader);
                    this.log(`MACåœ°å€: ${macAddress}`, 'success');
                    
                    // æµ‹è¯•å…¶ä»–ROMå±æ€§
                    this.log('æµ‹è¯•èŠ¯ç‰‡ä¿¡æ¯å±æ€§...', 'debug');
                    this.log(`èŠ¯ç‰‡åç§°: ${this.chip.CHIP_NAME}`, 'success');
                    this.log(`èŠ¯ç‰‡æ£€æµ‹å¯„å­˜å™¨åœ°å€: 0x${this.chip.CHIP_DETECT_MAGIC_REG_ADDR?.toString(16) || 'N/A'}`, 'info');
                    
                    this.updateTestCard('romTest', 'success');
                    this.log('=== ROMç³»ç»Ÿå¢å¼ºæµ‹è¯•å®Œæˆ ===', 'success');
                    
                } catch (error) {
                    this.log(`ROMç³»ç»Ÿæµ‹è¯•å¤±è´¥: ${error.message}`, 'error');
                    this.updateTestCard('romTest', 'error');
                }
            }

            async testTerminalInterface() {
                this.log('=== å¼€å§‹ç»ˆç«¯æ¥å£æµ‹è¯• ===', 'info');
                this.updateTestCard('terminalTest', 'running');
                
                try {
                    // æµ‹è¯•esptool-jsçœŸå®çš„è¾“å‡ºæ–¹æ³•
                    this.log('æµ‹è¯• write() æ–¹æ³•...', 'debug');
                    this.downloader.write('æµ‹è¯• write() è¾“å‡º');
                    
                    this.log('æµ‹è¯• info() æ–¹æ³•...', 'debug');
                    this.downloader.info('æµ‹è¯• info() è¾“å‡º');
                    
                    this.log('æµ‹è¯• debug() æ–¹æ³•...', 'debug');
                    this.downloader.debug('æµ‹è¯• debug() è¾“å‡º');
                    
                    this.log('æµ‹è¯• error() æ–¹æ³•...', 'debug');
                    this.downloader.error('æµ‹è¯• error() è¾“å‡º');
                    
                    // æµ‹è¯•ç»ˆç«¯ç›¸å…³å±æ€§
                    this.log('æ£€æŸ¥ç»ˆç«¯å±æ€§...', 'debug');
                    if (this.downloader.terminal) {
                        this.log('ç»ˆç«¯å®ä¾‹å­˜åœ¨ âœ“', 'success');
                    } else {
                        this.log('ç»ˆç«¯å®ä¾‹ä¸å­˜åœ¨ï¼ˆæ­£å¸¸æƒ…å†µï¼‰', 'info');
                    }
                    
                    this.updateTestCard('terminalTest', 'success');
                    this.log('=== ç»ˆç«¯æ¥å£æµ‹è¯•å®Œæˆ ===', 'success');
                    
                } catch (error) {
                    this.log(`ç»ˆç«¯æ¥å£æµ‹è¯•å¤±è´¥: ${error.message}`, 'error');
                    this.updateTestCard('terminalTest', 'error');
                }
            }

            async testErrorHandling() {
                this.log('=== å¼€å§‹é”™è¯¯å¤„ç†æµ‹è¯• ===', 'info');
                this.updateTestCard('errorTest', 'running');
                
                try {
                    // âœ… æµ‹è¯•è¶…æ—¶è®¾ç½®ï¼ˆä½¿ç”¨esptool-jsåŸç”Ÿæ–¹æ³•ï¼‰
                    this.log('æµ‹è¯•è¶…æ—¶è®¡ç®—...', 'debug');
                    const timeoutPerMb = this.downloader.timeoutPerMb(30, 1024 * 1024);
                    this.log(`è¶…æ—¶è®¡ç®—ç»“æœ: ${timeoutPerMb}ms`, 'success');
                    
                    // âœ… æµ‹è¯•è½¯é‡ç½®åŠŸèƒ½ï¼ˆæ–°å¢çš„esptool-jsæ–¹æ³•ï¼‰
                    this.log('æµ‹è¯•è½¯é‡ç½®åŠŸèƒ½...', 'debug');
                    try {
                        await this.downloader.softReset(true); // ä¿æŒåœ¨bootloaderæ¨¡å¼
                        this.log('softReset() æ‰§è¡ŒæˆåŠŸ', 'success');
                    } catch (e) {
                        this.log(`softReset() å¤±è´¥: ${e.message}`, 'warning');
                    }
                    
                    // âœ… æµ‹è¯•æ³¢ç‰¹ç‡æ›´æ”¹ï¼ˆæ–°å¢çš„esptool-jsæ–¹æ³•ï¼‰
                    this.log('æµ‹è¯•æ³¢ç‰¹ç‡æ›´æ”¹...', 'debug');
                    try {
                        // æ³¨æ„ï¼šè¿™é‡Œæµ‹è¯•changeBaudä½†ä¸å®é™…æ”¹å˜æ³¢ç‰¹ç‡ï¼Œå› ä¸ºå¯èƒ½å½±å“è¿æ¥
                        this.log('changeBaud() æ–¹æ³•å¯ç”¨', 'success');
                    } catch (e) {
                        this.log(`changeBaud() æµ‹è¯•å¤±è´¥: ${e.message}`, 'warning');
                    }
                    
                    // âœ… æµ‹è¯•StubåŠ è½½å™¨åŠŸèƒ½ï¼ˆæ–°å¢çš„esptool-jsæ–¹æ³•ï¼‰
                    this.log('æµ‹è¯•StubåŠ è½½å™¨çŠ¶æ€...', 'debug');
                    try {
                        const isStub = this.downloader.IS_STUB;
                        this.log(`å½“å‰è¿è¡Œæ¨¡å¼: ${isStub ? 'StubåŠ è½½å™¨' : 'ROMåŠ è½½å™¨'}`, 'success');
                        
                        // æµ‹è¯•syncStubDetectedå±æ€§
                        if (this.downloader.syncStubDetected !== undefined) {
                            this.log(`Stubæ£€æµ‹çŠ¶æ€: ${this.downloader.syncStubDetected}`, 'debug');
                        }
                    } catch (e) {
                        this.log(`StubçŠ¶æ€æ£€æµ‹å¤±è´¥: ${e.message}`, 'warning');
                    }
                    
                    // âœ… æµ‹è¯•é”™è¯¯å¤„ç† - è¯»å–ä¸å­˜åœ¨çš„å¯„å­˜å™¨
                    this.log('æµ‹è¯•é”™è¯¯å¤„ç†ï¼ˆè¯»å–æ— æ•ˆå¯„å­˜å™¨ï¼‰...', 'debug');
                    try {
                        await this.downloader.readReg(0xFFFFFFFF, 1000); // ä½¿ç”¨è¾ƒçŸ­è¶…æ—¶
                        this.log('æ„å¤–æˆåŠŸï¼šæ— æ•ˆå¯„å­˜å™¨è¯»å–åº”è¯¥å¤±è´¥', 'warning');
                    } catch (error) {
                        this.log(`é”™è¯¯å¤„ç†æ­£å¸¸: ${error.message}`, 'success');
                    }
                    
                    // âœ… æµ‹è¯•å‘½ä»¤æ‰§è¡Œï¼ˆä½¿ç”¨esptool-jsåŸç”Ÿå‘½ä»¤å¸¸é‡ï¼‰
                    this.log('æµ‹è¯•åŸºç¡€å‘½ä»¤...', 'debug');
                    const [response, data] = await this.downloader.command(
                        this.downloader.ESP_READ_REG, 
                        this.downloader._intToByteArray(this.downloader.CHIP_DETECT_MAGIC_REG_ADDR)
                    );
                    this.log(`å‘½ä»¤æ‰§è¡ŒæˆåŠŸ: å“åº”=${response}`, 'success');
                    
                    // âœ… æµ‹è¯•checkCommandæ–¹æ³•ï¼ˆesptool-jså†…éƒ¨æ–¹æ³•ï¼‰
                    this.log('æµ‹è¯•checkCommand()...', 'debug');
                    try {
                        const checkResult = await this.downloader.checkCommand(
                            'READ_REGæµ‹è¯•', 
                            this.downloader.ESP_READ_REG,
                            this.downloader._intToByteArray(this.downloader.CHIP_DETECT_MAGIC_REG_ADDR)
                        );
                        this.log(`checkCommand() æ‰§è¡ŒæˆåŠŸ`, 'success');
                    } catch (e) {
                        this.log(`checkCommand() å¤±è´¥: ${e.message}`, 'warning');
                    }
                    
                    // âœ… æµ‹è¯•æ•°æ®åŒ…è¯»å–åŠŸèƒ½ï¼ˆæ–°å¢çš„esptool-jsæ–¹æ³•ï¼‰
                    this.log('æµ‹è¯•readPacket()åŠŸèƒ½...', 'debug');
                    try {
                        // æµ‹è¯•readPacketæ–¹æ³•æ˜¯å¦å¯ç”¨ï¼ˆä¸å®é™…è¯»å–ä»¥å…å½±å“çŠ¶æ€ï¼‰
                        if (typeof this.downloader.readPacket === 'function') {
                            this.log('readPacket() æ–¹æ³•å¯ç”¨', 'success');
                        }
                    } catch (e) {
                        this.log(`readPacket() æµ‹è¯•å¤±è´¥: ${e.message}`, 'warning');
                    }
                    
                    // âœ… æµ‹è¯•æ˜ åƒæ›´æ–°åŠŸèƒ½ï¼ˆæ–°å¢æµ‹è¯•ï¼‰
                    this.log('æµ‹è¯•æ˜ åƒå‚æ•°æ›´æ–°åŠŸèƒ½...', 'debug');
                    try {
                        if (typeof this.downloader._updateImageFlashParams === 'function') {
                            this.log('_updateImageFlashParams() æ–¹æ³•å¯ç”¨', 'success');
                        }
                        
                        // æµ‹è¯•ç›¸å…³å¸¸é‡
                        if (typeof this.downloader.ESP_IMAGE_MAGIC !== 'undefined') {
                            this.log(`ESP_IMAGE_MAGIC: 0x${this.downloader.ESP_IMAGE_MAGIC.toString(16)}`, 'debug');
                        }
                        if (typeof this.downloader.ESP_CHECKSUM_MAGIC !== 'undefined') {
                            this.log(`ESP_CHECKSUM_MAGIC: 0x${this.downloader.ESP_CHECKSUM_MAGIC.toString(16)}`, 'debug');
                        }
                    } catch (e) {
                        this.log(`æ˜ åƒå‚æ•°åŠŸèƒ½æµ‹è¯•å¤±è´¥: ${e.message}`, 'warning');
                    }
                    
                    this.updateTestCard('errorTest', 'success');
                    this.log('=== é”™è¯¯å¤„ç†æµ‹è¯•å®Œæˆ ===', 'success');
                    
                } catch (error) {
                    this.log(`é”™è¯¯å¤„ç†æµ‹è¯•å¤±è´¥: ${error.message}`, 'error');
                    this.updateTestCard('errorTest', 'error');
                }
            }

            async testPerformanceBenchmark() {
                this.log('=== å¼€å§‹æ€§èƒ½åŸºå‡†æµ‹è¯• ===', 'info');
                this.updateTestCard('performanceTest', 'running');
                
                try {
                    // âœ… æµ‹è¯•åŒæ­¥æ€§èƒ½ï¼ˆä½¿ç”¨esptool-jsåŸç”Ÿæ–¹æ³•ï¼‰
                    this.log('æµ‹è¯•åŒæ­¥æ€§èƒ½...', 'debug');
                    const syncStart = performance.now();
                    await this.downloader.sync();
                    const syncTime = performance.now() - syncStart;
                    this.log(`åŒæ­¥ç”¨æ—¶: ${Math.round(syncTime)}ms`, 'success');
                    
                    // âœ… æµ‹è¯•è¯»å–å¯„å­˜å™¨æ€§èƒ½
                    this.log('æµ‹è¯•å¯„å­˜å™¨è¯»å–æ€§èƒ½...', 'debug');
                    const regStart = performance.now();
                    await this.downloader.readReg(this.downloader.CHIP_DETECT_MAGIC_REG_ADDR);
                    const regTime = performance.now() - regStart;
                    this.log(`å¯„å­˜å™¨è¯»å–ç”¨æ—¶: ${Math.round(regTime)}ms`, 'success');
                    
                    // âœ… æµ‹è¯•æ•°æ®å¤„ç†æ€§èƒ½
                    this.log('æµ‹è¯•æ•°æ®å¤„ç†æ€§èƒ½...', 'debug');
                    const dataStart = performance.now();
                    const testData = new Uint8Array(1000).fill(0xAA);
                    for (let i = 0; i < 100; i++) {
                        this.downloader.checksum(testData);
                    }
                    const dataTime = performance.now() - dataStart;
                    this.log(`æ•°æ®å¤„ç†ç”¨æ—¶: ${Math.round(dataTime)}ms (100æ¬¡æ ¡éªŒå’Œè®¡ç®—)`, 'success');
                    
                    // âœ… æµ‹è¯•é«˜çº§esptool-jsåŠŸèƒ½
                    this.log('æµ‹è¯•é«˜çº§åŠŸèƒ½...', 'debug');
                    
                    // æµ‹è¯•å†…å­˜æ“ä½œç›¸å…³å¸¸é‡å’Œæ–¹æ³•
                    this.log('æµ‹è¯•å†…å­˜æ“ä½œå¸¸é‡...', 'debug');
                    const memConstants = [
                        'ESP_MEM_BEGIN', 'ESP_MEM_DATA', 'ESP_MEM_END',
                        'ESP_WRITE_REG', 'ESP_READ_REG', 'ESP_RAM_BLOCK'
                    ];
                    memConstants.forEach(constant => {
                        if (this.downloader[constant] !== undefined) {
                            this.log(`${constant}: 0x${this.downloader[constant].toString(16)}`, 'debug');
                        }
                    });
                    
                    // æµ‹è¯•Flashæ“ä½œå¸¸é‡
                    this.log('æµ‹è¯•Flashæ“ä½œå¸¸é‡...', 'debug');
                    const flashConstants = [
                        'ESP_FLASH_BEGIN', 'ESP_FLASH_DATA', 'ESP_FLASH_END',
                        'ESP_FLASH_DEFL_BEGIN', 'ESP_FLASH_DEFL_DATA', 'ESP_FLASH_DEFL_END'
                    ];
                    flashConstants.forEach(constant => {
                        if (this.downloader[constant] !== undefined) {
                            this.log(`${constant}: 0x${this.downloader[constant].toString(16)}`, 'debug');
                        }
                    });
                    
                    // æµ‹è¯•è¶…æ—¶å¸¸é‡
                    this.log('æµ‹è¯•è¶…æ—¶å¸¸é‡...', 'debug');
                    const timeoutConstants = [
                        'DEFAULT_TIMEOUT', 'CHIP_ERASE_TIMEOUT', 'MAX_TIMEOUT'
                    ];
                    timeoutConstants.forEach(constant => {
                        if (this.downloader[constant] !== undefined) {
                            this.log(`${constant}: ${this.downloader[constant]}ms`, 'debug');
                        }
                    });
                    
                    // âœ… æµ‹è¯•Flash sizeæ£€æµ‹ï¼ˆæ–°å¢çš„å®Œæ•´åŠŸèƒ½æµ‹è¯•ï¼‰
                    this.log('æµ‹è¯•Flash sizeæ£€æµ‹åŠŸèƒ½...', 'debug');
                    try {
                        const detectedSizes = this.downloader.DETECTED_FLASH_SIZES;
                        if (detectedSizes) {
                            this.log(`æ”¯æŒçš„Flash sizeæ£€æµ‹: ${Object.keys(detectedSizes).length}ç§`, 'debug');
                        }
                        
                        const detectedSizesNum = this.downloader.DETECTED_FLASH_SIZES_NUM;
                        if (detectedSizesNum) {
                            this.log(`Flash sizeæ•°å€¼æ˜ å°„: ${Object.keys(detectedSizesNum).length}ç§`, 'debug');
                        }
                    } catch (e) {
                        this.log(`Flash sizeæ£€æµ‹åŠŸèƒ½æµ‹è¯•å¤±è´¥: ${e.message}`, 'warning');
                    }
                    
                    // âœ… æµ‹è¯•ç¡çœ åŠŸèƒ½ï¼ˆesptool-jså†…éƒ¨æ–¹æ³•ï¼‰
                    this.log('æµ‹è¯•ç¡çœ åŠŸèƒ½...', 'debug');
                    try {
                        const sleepStart = performance.now();
                        await this.downloader._sleep(100); // ç¡çœ 100ms
                        const sleepTime = performance.now() - sleepStart;
                        this.log(`ç¡çœ åŠŸèƒ½æµ‹è¯•: é¢„æœŸ100ms, å®é™…${Math.round(sleepTime)}ms`, 'success');
                    } catch (e) {
                        this.log(`ç¡çœ åŠŸèƒ½æµ‹è¯•å¤±è´¥: ${e.message}`, 'warning');
                    }
                    
                    this.updateTestCard('performanceTest', 'success');
                    this.log('=== æ€§èƒ½åŸºå‡†æµ‹è¯•å®Œæˆ ===', 'success');
                    
                } catch (error) {
                    this.log(`æ€§èƒ½æµ‹è¯•å¤±è´¥: ${error.message}`, 'error');
                    this.updateTestCard('performanceTest', 'error');
                }
            }

            async testFlashWriteOperations() {
                this.log('=== å¼€å§‹Flashå†™å…¥æ“ä½œæµ‹è¯• ===', 'info');
                this.updateTestCard('flashWriteTest', 'running');
                
                try {
                    // âœ… æµ‹è¯•flashBeginæ–¹æ³•
                    this.log('æµ‹è¯• flashBegin() æ–¹æ³•...', 'debug');
                    try {
                        // æµ‹è¯•ä¸€ä¸ªå°çš„å†™å…¥åŒºåŸŸ
                        const testSize = 4096; // 4KB
                        const testOffset = 0x100000; // 1MBåç§»
                        const blocks = await this.downloader.flashBegin(testSize, testOffset);
                        this.log(`flashBegin() æˆåŠŸ: ${blocks}ä¸ªæ•°æ®å—`, 'success');
                    } catch (e) {
                        this.log(`flashBegin() å¤±è´¥: ${e.message}`, 'warning');
                    }
                    
                    // âœ… æµ‹è¯•flashBlockæ–¹æ³•ï¼ˆç©ºå®ç°æµ‹è¯•ï¼‰
                    this.log('æµ‹è¯• flashBlock() æ–¹æ³•...', 'debug');
                    try {
                        if (typeof this.downloader.flashBlock === 'function') {
                            this.log('flashBlock() æ–¹æ³•å¯ç”¨', 'success');
                        }
                    } catch (e) {
                        this.log(`flashBlock() æµ‹è¯•å¤±è´¥: ${e.message}`, 'warning');
                    }
                    
                    // âœ… æµ‹è¯•flashFinishæ–¹æ³•
                    this.log('æµ‹è¯• flashFinish() æ–¹æ³•...', 'debug');
                    try {
                        await this.downloader.flashFinish(false); // ä¸é‡å¯
                        this.log('flashFinish() æ‰§è¡ŒæˆåŠŸ', 'success');
                    } catch (e) {
                        this.log(`flashFinish() å¤±è´¥: ${e.message}`, 'warning');
                    }
                    
                    // âœ… æµ‹è¯•å‹ç¼©Flashæ“ä½œ
                    this.log('æµ‹è¯•å‹ç¼©Flashæ“ä½œæ–¹æ³•...', 'debug');
                    const deflMethods = ['flashDeflBegin', 'flashDeflBlock', 'flashDeflFinish'];
                    deflMethods.forEach(method => {
                        if (typeof this.downloader[method] === 'function') {
                            this.log(`${method}() æ–¹æ³•å¯ç”¨`, 'success');
                        } else {
                            this.log(`${method}() æ–¹æ³•ä¸å¯ç”¨`, 'warning');
                        }
                    });
                    
                    // âœ… æµ‹è¯•writeFlashé«˜çº§æ¥å£
                    this.log('æµ‹è¯• writeFlash() é«˜çº§æ¥å£...', 'debug');
                    try {
                        if (typeof this.downloader.writeFlash === 'function') {
                            this.log('writeFlash() æ–¹æ³•å¯ç”¨ (å®Œæ•´çš„Flashå†™å…¥åŠŸèƒ½)', 'success');
                        }
                    } catch (e) {
                        this.log(`writeFlash() æµ‹è¯•å¤±è´¥: ${e.message}`, 'warning');
                    }
                    
                    this.updateTestCard('flashWriteTest', 'success');
                    this.testResults.flashWriteTest = true;
                    this.completedTests++;
                    this.log('=== Flashå†™å…¥æ“ä½œæµ‹è¯•å®Œæˆ ===', 'success');
                    
                } catch (error) {
                    this.log(`Flashå†™å…¥æ“ä½œæµ‹è¯•å¤±è´¥: ${error.message}`, 'error');
                    this.updateTestCard('flashWriteTest', 'error');
                    this.testResults.flashWriteTest = false;
                    this.completedTests++;
                }
                this.updateProgress();
            }

            async testMemoryOperations() {
                this.log('=== å¼€å§‹å†…å­˜æ“ä½œæµ‹è¯• ===', 'info');
                this.updateTestCard('memoryTest', 'running');
                
                try {
                    // âœ… æµ‹è¯•memBeginæ–¹æ³•
                    this.log('æµ‹è¯• memBegin() æ–¹æ³•...', 'debug');
                    try {
                        const testSize = 1024; // 1KB
                        const blocks = 1;
                        const blockSize = 1024; 
                        const offset = 0x40080000; // ESP32 DRAMåŒºåŸŸ
                        await this.downloader.memBegin(testSize, blocks, blockSize, offset);
                        this.log('memBegin() æ‰§è¡ŒæˆåŠŸ', 'success');
                    } catch (e) {
                        this.log(`memBegin() å¤±è´¥: ${e.message}`, 'warning');
                        this.log('è¿™å¯èƒ½æ˜¯æ­£å¸¸çš„ï¼Œå› ä¸ºæˆ‘ä»¬æ²¡æœ‰å®é™…çš„æ•°æ®è¦å†™å…¥', 'info');
                    }
                    
                    // âœ… æµ‹è¯•memBlockå’ŒmemFinishæ–¹æ³•
                    this.log('æµ‹è¯•å†…å­˜æ“ä½œæ–¹æ³•...', 'debug');
                    const memMethods = ['memBlock', 'memFinish'];
                    memMethods.forEach(method => {
                        if (typeof this.downloader[method] === 'function') {
                            this.log(`${method}() æ–¹æ³•å¯ç”¨`, 'success');
                        } else {
                            this.log(`${method}() æ–¹æ³•ä¸å¯ç”¨`, 'warning');
                        }
                    });
                    
                    // âœ… æµ‹è¯•å†…å­˜ç›¸å…³å¸¸é‡
                    this.log('æµ‹è¯•å†…å­˜æ“ä½œå¸¸é‡...', 'debug');
                    const memConstants = ['ESP_MEM_BEGIN', 'ESP_MEM_DATA', 'ESP_MEM_END', 'ESP_RAM_BLOCK'];
                    memConstants.forEach(constant => {
                        if (this.downloader[constant] !== undefined) {
                            this.log(`${constant}: 0x${this.downloader[constant].toString(16)}`, 'debug');
                        }
                    });
                    
                    this.updateTestCard('memoryTest', 'success');
                    this.testResults.memoryTest = true;
                    this.completedTests++;
                    this.log('=== å†…å­˜æ“ä½œæµ‹è¯•å®Œæˆ ===', 'success');
                    
                } catch (error) {
                    this.log(`å†…å­˜æ“ä½œæµ‹è¯•å¤±è´¥: ${error.message}`, 'error');
                    this.updateTestCard('memoryTest', 'error');
                    this.testResults.memoryTest = false;
                    this.completedTests++;
                }
                this.updateProgress();
            }

            async testStubLoader() {
                this.log('=== å¼€å§‹StubåŠ è½½å™¨æµ‹è¯• ===', 'info');
                this.updateTestCard('stubTest', 'running');
                
                try {
                    // âœ… æµ‹è¯•å½“å‰StubçŠ¶æ€
                    this.log('æ£€æŸ¥å½“å‰StubçŠ¶æ€...', 'debug');
                    const isStub = this.downloader.IS_STUB;
                    this.log(`å½“å‰æ¨¡å¼: ${isStub ? 'StubåŠ è½½å™¨æ¨¡å¼' : 'ROMåŠ è½½å™¨æ¨¡å¼'}`, isStub ? 'success' : 'info');
                    
                    // âœ… æµ‹è¯•runStubæ–¹æ³•ï¼ˆå¦‚æœå½“å‰æ˜¯ROMæ¨¡å¼ï¼‰
                    if (!isStub) {
                        this.log('æµ‹è¯• runStub() æ–¹æ³•...', 'debug');
                        try {
                            if (typeof this.downloader.runStub === 'function') {
                                this.log('runStub() æ–¹æ³•å¯ç”¨', 'success');
                                this.log('runStub() ä¼šå®é™…è¿è¡ŒStubï¼Œå‡ºäºå®‰å…¨è€ƒè™‘ä¸æ‰§è¡Œ', 'info');
                            }
                        } catch (e) {
                            this.log(`runStub() æµ‹è¯•å¤±è´¥: ${e.message}`, 'warning');
                        }
                    } else {
                        this.log('å·²åœ¨Stubæ¨¡å¼ï¼ŒrunStub() ä¸éœ€è¦é‡å¤æ‰§è¡Œ', 'success');
                    }
                    
                    // âœ… æµ‹è¯•eraseFlashæ–¹æ³•ï¼ˆä»…Stubæ”¯æŒï¼‰
                    this.log('æµ‹è¯• eraseFlash() æ–¹æ³•...', 'debug');
                    try {
                        if (typeof this.downloader.eraseFlash === 'function') {
                            this.log('eraseFlash() æ–¹æ³•å¯ç”¨', 'success');
                            if (isStub) {
                                this.log('å½“å‰åœ¨Stubæ¨¡å¼ï¼ŒeraseFlash() å®Œå…¨æ”¯æŒ', 'success');
                            } else {
                                this.log('å½“å‰åœ¨ROMæ¨¡å¼ï¼ŒeraseFlash() å¯èƒ½ä¸æ”¯æŒ', 'info');
                            }
                        }
                    } catch (e) {
                        this.log(`eraseFlash() æµ‹è¯•å¤±è´¥: ${e.message}`, 'warning');
                    }
                    
                    // âœ… æµ‹è¯•ESP_ERASE_REGIONå¸¸é‡ (æ³¨æ„ï¼šeraseRegionæ–¹æ³•åœ¨esptool-jsä¸­ä¸å­˜åœ¨ï¼Œåªæœ‰å¸¸é‡)
                    this.log('æµ‹è¯• ESP_ERASE_REGION å¸¸é‡...', 'debug');
                    if (this.downloader.ESP_ERASE_REGION !== undefined) {
                        this.log(`ESP_ERASE_REGION: 0x${this.downloader.ESP_ERASE_REGION.toString(16)}`, 'success');
                        this.log('æ³¨æ„ï¼šeraseRegion()æ–¹æ³•åœ¨esptool-jsä¸­ä¸å­˜åœ¨ï¼Œåªæœ‰åè®®å¸¸é‡', 'info');
                    } else {
                        this.log('ESP_ERASE_REGION å¸¸é‡ä¸å¯ç”¨', 'warning');
                    }
                    
                    // âœ… æµ‹è¯•Stubä¸“ç”¨å¸¸é‡
                    this.log('æµ‹è¯•Stubä¸“ç”¨å¸¸é‡...', 'debug');
                    const stubConstants = ['ESP_ERASE_FLASH', 'ESP_ERASE_REGION', 'ESP_READ_FLASH', 'ESP_RUN_USER_CODE'];
                    stubConstants.forEach(constant => {
                        if (this.downloader[constant] !== undefined) {
                            this.log(`${constant}: 0x${this.downloader[constant].toString(16)}`, 'debug');
                        }
                    });
                    
                    // âœ… æµ‹è¯•Stubæ£€æµ‹çŠ¶æ€
                    if (this.downloader.syncStubDetected !== undefined) {
                        this.log(`syncStubDetected: ${this.downloader.syncStubDetected}`, 'debug');
                    }
                    
                    this.updateTestCard('stubTest', 'success');
                    this.testResults.stubTest = true;
                    this.completedTests++;
                    this.log('=== StubåŠ è½½å™¨æµ‹è¯•å®Œæˆ ===', 'success');
                    
                } catch (error) {
                    this.log(`StubåŠ è½½å™¨æµ‹è¯•å¤±è´¥: ${error.message}`, 'error');
                    this.updateTestCard('stubTest', 'error');
                    this.testResults.stubTest = false;
                    this.completedTests++;
                }
                this.updateProgress();
            }

            async testAdvancedFeatures() {
                this.log('=== å¼€å§‹é«˜çº§åŠŸèƒ½æµ‹è¯• ===', 'info');
                this.updateTestCard('advancedTest', 'running');
                
                try {
                    // âœ… æµ‹è¯•_connectAttemptæ–¹æ³•
                    this.log('æµ‹è¯• _connectAttempt() æ–¹æ³•...', 'debug');
                    try {
                        if (typeof this.downloader._connectAttempt === 'function') {
                            this.log('_connectAttempt() æ–¹æ³•å¯ç”¨', 'success');
                        }
                    } catch (e) {
                        this.log(`_connectAttempt() æµ‹è¯•å¤±è´¥: ${e.message}`, 'warning');
                    }
                    
                    // âœ… æµ‹è¯•changeBaudæ–¹æ³•
                    this.log('æµ‹è¯• changeBaud() æ–¹æ³•...', 'debug');
                    try {
                        if (typeof this.downloader.changeBaud === 'function') {
                            this.log('changeBaud() æ–¹æ³•å¯ç”¨', 'success');
                        }
                    } catch (e) {
                        this.log(`changeBaud() æµ‹è¯•å¤±è´¥: ${e.message}`, 'warning');
                    }
                    
                    // âœ… æµ‹è¯•softResetæ–¹æ³•
                    this.log('æµ‹è¯• softReset() æ–¹æ³•...', 'debug');
                    try {
                        if (typeof this.downloader.softReset === 'function') {
                            this.log('softReset() æ–¹æ³•å¯ç”¨', 'success');
                        }
                    } catch (e) {
                        this.log(`softReset() æµ‹è¯•å¤±è´¥: ${e.message}`, 'warning');
                    }
                    
                    // âœ… æµ‹è¯•Flashå†™å…¥å¤§å°å¸¸é‡
                    this.log('æµ‹è¯•Flashå†™å…¥å‚æ•°...', 'debug');
                    if (this.downloader.FLASH_WRITE_SIZE !== undefined) {
                        this.log(`FLASH_WRITE_SIZE: ${this.downloader.FLASH_WRITE_SIZE} bytes`, 'success');
                    }
                    
                    // âœ… æµ‹è¯•æ‰€æœ‰è¶…æ—¶å¸¸é‡
                    this.log('æµ‹è¯•æ‰€æœ‰è¶…æ—¶å¸¸é‡...', 'debug');
                    const timeoutConstants = [
                        'ERASE_REGION_TIMEOUT_PER_MB', 'ERASE_WRITE_TIMEOUT_PER_MB', 
                        'MD5_TIMEOUT_PER_MB', 'FLASH_READ_TIMEOUT'
                    ];
                    timeoutConstants.forEach(constant => {
                        if (this.downloader[constant] !== undefined) {
                            this.log(`${constant}: ${this.downloader[constant]}ms`, 'debug');
                        }
                    });
                    
                    // âœ… æµ‹è¯•readPacketæ–¹æ³•
                    this.log('æµ‹è¯• readPacket() æ–¹æ³•...', 'debug');
                    try {
                        if (typeof this.downloader.readPacket === 'function') {
                            this.log('readPacket() æ–¹æ³•å¯ç”¨', 'success');
                        }
                    } catch (e) {
                        this.log(`readPacket() æµ‹è¯•å¤±è´¥: ${e.message}`, 'warning');
                    }
                    
                    // âœ… æµ‹è¯•flashMd5sumæ–¹æ³•
                    this.log('æµ‹è¯• flashMd5sum() æ–¹æ³•...', 'debug');
                    try {
                        if (typeof this.downloader.flashMd5sum === 'function') {
                            this.log('flashMd5sum() æ–¹æ³•å¯ç”¨', 'success');
                        }
                    } catch (e) {
                        this.log(`flashMd5sum() æµ‹è¯•å¤±è´¥: ${e.message}`, 'warning');
                    }
                    
                    // âœ… æµ‹è¯•esptool-jså·¥å…·æ–¹æ³• - decodeBase64Data
                    this.log('æµ‹è¯• decodeBase64Data()...', 'debug');
                    try {
                        if (typeof window.esptooljs.decodeBase64Data === 'function') {
                            const testBase64 = 'SGVsbG8gV29ybGQ='; // "Hello World" in base64
                            const decoded = window.esptooljs.decodeBase64Data(testBase64);
                            this.log(`decodeBase64Data() æµ‹è¯•æˆåŠŸ: ${new TextDecoder().decode(decoded)}`, 'success');
                        } else {
                            this.log('decodeBase64Data() æ–¹æ³•ä¸å¯ç”¨', 'warning');
                        }
                    } catch (e) {
                        this.log(`decodeBase64Data() æµ‹è¯•å¤±è´¥: ${e.message}`, 'warning');
                    }
                    
                    // âœ… æµ‹è¯•esptool-jså·¥å…·æ–¹æ³• - getStubJsonByChipName
                    this.log('æµ‹è¯• getStubJsonByChipName()...', 'debug');
                    try {
                        if (typeof window.esptooljs.getStubJsonByChipName === 'function') {
                            // æµ‹è¯•è·å–å½“å‰èŠ¯ç‰‡çš„Stubä¿¡æ¯
                            const chipName = this.chip?.CHIP_NAME || 'ESP32';
                            const stubInfo = await window.esptooljs.getStubJsonByChipName(chipName);
                            if (stubInfo) {
                                this.log(`getStubJsonByChipName() æˆåŠŸï¼Œè·å–${chipName} Stubä¿¡æ¯`, 'success');
                                this.log(`Stubå…¥å£ç‚¹: 0x${stubInfo.entry.toString(16)}`, 'debug');
                                this.log(`Textæ®µ: ${stubInfo.decodedText.length} bytes`, 'debug');
                                this.log(`Dataæ®µ: ${stubInfo.decodedData.length} bytes`, 'debug');
                            }
                        } else {
                            this.log('getStubJsonByChipName() æ–¹æ³•ä¸å¯ç”¨', 'warning');
                        }
                    } catch (e) {
                        this.log(`getStubJsonByChipName() æµ‹è¯•å¤±è´¥: ${e.message}`, 'warning');
                    }
                    
                    // âœ… æµ‹è¯•esptool-jså·¥å…·æ–¹æ³• - validateCustomResetStringSequence
                    this.log('æµ‹è¯• validateCustomResetStringSequence()...', 'debug');
                    try {
                        if (typeof window.esptooljs.validateCustomResetStringSequence === 'function') {
                            const testSequence = 'D0|R1|W100|D1|R0|W50|D0';
                            const isValid = window.esptooljs.validateCustomResetStringSequence(testSequence);
                            this.log(`validateCustomResetStringSequence() æµ‹è¯•: ${testSequence} -> ${isValid ? 'æœ‰æ•ˆ' : 'æ— æ•ˆ'}`, 'success');
                        } else {
                            this.log('validateCustomResetStringSequence() æ–¹æ³•ä¸å¯ç”¨', 'warning');
                        }
                    } catch (e) {
                        this.log(`validateCustomResetStringSequence() æµ‹è¯•å¤±è´¥: ${e.message}`, 'warning');
                    }
                    
                    this.updateTestCard('advancedTest', 'success');
                    this.testResults.advancedTest = true;
                    this.completedTests++;
                    this.log('=== é«˜çº§åŠŸèƒ½æµ‹è¯•å®Œæˆ ===', 'success');
                    
                } catch (error) {
                    this.log(`é«˜çº§åŠŸèƒ½æµ‹è¯•å¤±è´¥: ${error.message}`, 'error');
                    this.updateTestCard('advancedTest', 'error');
                    this.testResults.advancedTest = false;
                    this.completedTests++;
                }
                this.updateProgress();
            }

            async disconnect() {
                try {
                    this.log('å¼€å§‹æ–­å¼€è¿æ¥...', 'info');
                    
                    if (this.downloader) {
                        // âœ… ä½¿ç”¨esptool-jsæ ‡å‡†çš„åæ“ä½œæ–¹æ³•
                        this.log('æ‰§è¡Œ after() åæ“ä½œ...', 'debug');
                        try {
                            await this.downloader.after('hard_reset');
                            this.log('after() åæ“ä½œå®Œæˆ', 'success');
                        } catch (e) {
                            this.log(`after() æ“ä½œå¤±è´¥: ${e.message}`, 'warning');
                        }
                        
                        // âœ… ä½¿ç”¨esptool-jsä¼ è¾“å±‚æ ‡å‡†æ–­å¼€
                        this.log('æ–­å¼€Transportè¿æ¥...', 'debug');
                        if (this.downloader.transport) {
                            await this.downloader.transport.disconnect();
                            this.log('Transportæ–­å¼€å®Œæˆ', 'success');
                        }
                    }
                    
                    // æ¸…ç†ä¸²å£è¿æ¥
                    if (this.serialPort && this.serialPort.readable) {
                        this.log('å…³é—­ä¸²å£...', 'debug');
                        await this.serialPort.close();
                        this.log('ä¸²å£å…³é—­å®Œæˆ', 'success');
                    }
                    
                    // æ¸…ç†å®ä¾‹å¼•ç”¨
                    this.serialPort = null;
                    this.downloader = null;
                    this.chip = null;
                    
                    this.updateStatus('å·²æ–­å¼€è¿æ¥', 'info');
                    document.getElementById('chipInfo').style.display = 'none';
                    
                    // æ¢å¤æŒ‰é’®çŠ¶æ€
                    document.getElementById('connectBtn').disabled = false;
                    const buttons = [
                        'testBasicBtn', 'testDataBtn', 'testFlashBtn', 'testResetBtn',
                        'testRomBtn', 'testTerminalBtn', 'testErrorBtn', 'testPerformanceBtn',
                        'testFlashWriteBtn', 'testMemoryBtn', 'testStubBtn', 'testAdvancedBtn',
                        'disconnectBtn', 'detectChipBtn'
                    ];
                    buttons.forEach(id => {
                        document.getElementById(id).disabled = true;
                    });
                    
                    this.log('æ–­å¼€è¿æ¥å®Œæˆ', 'success');
                    
                } catch (error) {
                    this.log(`æ–­å¼€è¿æ¥å¤±è´¥: ${error.message}`, 'error');
                }
            }

            async runMockTest() {
                this.log('========== å¼€å§‹æ¨¡æ‹Ÿæµ‹è¯•æ¨¡å¼ ==========', 'info');
                this.log('ğŸ§ª åœ¨æ²¡æœ‰ESP32è®¾å¤‡çš„æƒ…å†µä¸‹æµ‹è¯•æ‰€æœ‰åŠŸèƒ½', 'info');
                
                try {
                    // æ¨¡æ‹Ÿè¿æ¥
                    this.log('ğŸ” æ¨¡æ‹ŸESP32è®¾å¤‡è¿æ¥...', 'info');
                    await new Promise(resolve => setTimeout(resolve, 500));
                    
                    // åˆ›å»ºå®Œæ•´çš„æ¨¡æ‹ŸåŒ…è£…å™¨å®ä¾‹ - ä¸é‡å¤é€ è½®å­ï¼Œå¤ç”¨ç°æœ‰æ–¹æ³•
                    this.downloader = {
                        // èŠ¯ç‰‡ä¿¡æ¯
                        detectedChip: {
                            CHIP_NAME: 'ESP32-S3 (Mock)',
                            getChipDescription: async () => 'ESP32-S3 Mock Device',
                            getChipFeatures: async () => ['WiFi', 'BLE', 'PSRAM'],
                            getCrystalFreq: async () => 40,
                            readMac: async () => '24:0A:C4:XX:XX:XX'
                        },
                        
                        // åŸºç¡€è¿æ¥çŠ¶æ€
                        isConnected: () => true,
                        
                        // âœ… ä½¿ç”¨ç®€å•çš„æ¨¡æ‹Ÿè¿”å›ï¼Œä¸é‡æ–°å®ç°esptool-jsåŠŸèƒ½
                        sync: async () => [0xC0, new Uint8Array([0x00, 0x08])],
                        readReg: async (addr) => 0x15122500, // æ¨¡æ‹ŸESP32èŠ¯ç‰‡æ£€æµ‹å€¼
                        writeReg: async () => {},
                        flushInput: async () => {},
                        readFlashId: async () => 0x001640EF,
                        getFlashSize: async () => '8MB',
                        
                        // Flashæ“ä½œ - ç®€å•æ¨¡æ‹Ÿå“åº”
                        flashBegin: async () => {},
                        flashBlock: async () => {},
                        flashFinish: async () => {},
                        flashDeflBegin: async () => {},
                        flashDeflBlock: async () => {},
                        flashDeflFinish: async () => {},
                        
                        // å†…å­˜æ“ä½œ
                        memBegin: async () => {},
                        memBlock: async () => {},
                        memFinish: async () => {},
                        
                        // é«˜çº§åŠŸèƒ½
                        IS_STUB: false,
                        _connectAttempt: async () => {},
                        changeBaud: async () => {},
                        softReset: async () => {},
                        FLASH_WRITE_SIZE: 0x4000,
                        
                        // å·¥å…·æ–¹æ³• - ç®€å•æ¨¡æ‹Ÿï¼Œä¸é‡æ–°å®ç°
                        _intToByteArray: () => [0x00, 0x01, 0x02, 0x03],
                        _byteArrayToInt: () => 0x03020100,
                        _shortToBytearray: () => [0x34, 0x12],
                        _byteArrayToShort: () => 0x1234,
                        _appendArray: () => new Uint8Array([1, 2, 3, 4]),
                        checksum: () => 0xAB,
                        toHex: () => "00 01 02 03",
                        
                        // ç»ˆç«¯æ–¹æ³•
                        write: (msg) => this.log(`[Mock Terminal] ${msg}`, 'debug'),
                        info: (msg) => this.log(`[Mock Info] ${msg}`, 'info'),
                        debug: (msg) => this.log(`[Mock Debug] ${msg}`, 'debug'),
                        error: (msg) => this.log(`[Mock Error] ${msg}`, 'error'),
                        
                        // å…¶ä»–ç¼ºå¤±çš„æ–¹æ³• - ç®€å•æ¨¡æ‹Ÿï¼Œä¸é‡æ–°å®ç°åŠŸèƒ½
                        command: async () => [0x00, new Uint8Array([0x00, 0x00])],
                        _sleep: async () => {},
                        
                        // å…¶ä»–å±æ€§
                        timeoutPerMb: () => 3000,
                        CHIP_DETECT_MAGIC_REG_ADDR: 0x40001000
                    };
                    
                    // è®¾ç½®chipå¼•ç”¨ï¼ŒæŒ‡å‘detectedChip
                    this.chip = this.downloader.detectedChip;
                    
                    this.log('âœ… æ¨¡æ‹Ÿè¿æ¥æˆåŠŸï¼šESP32-S3 (Mock)', 'success');
                    this.updateStatus('å·²è¿æ¥åˆ°æ¨¡æ‹Ÿè®¾å¤‡', 'success');
                    
                    // æ˜¾ç¤ºæ¨¡æ‹ŸèŠ¯ç‰‡ä¿¡æ¯
                    document.getElementById('chipInfo').style.display = 'block';
                    document.getElementById('chipType').textContent = 'ESP32-S3 (Mock)';
                    document.getElementById('chipDesc').textContent = 'æ¨¡æ‹Ÿè®¾å¤‡ç”¨äºæµ‹è¯•';
                    document.getElementById('chipMac').textContent = '24:0A:C4:XX:XX:XX';
                    document.getElementById('chipFreq').textContent = '40MHz (Mock)';
                    document.getElementById('chipFlash').textContent = '8MB (Mock)';
                    document.getElementById('chipFeatures').textContent = 'WiFi, BLE, PSRAM';
                    
                    // å¯ç”¨æ‰€æœ‰æµ‹è¯•æŒ‰é’®
                    const testButtons = [
                        'testBasicBtn', 'testDataBtn', 'testFlashBtn', 'testResetBtn',
                        'testRomBtn', 'testTerminalBtn', 'testErrorBtn', 'testPerformanceBtn',
                        'testFlashWriteBtn', 'testMemoryBtn', 'testStubBtn', 'testAdvancedBtn'
                    ];
                    
                    testButtons.forEach(btnId => {
                        const btn = document.getElementById(btnId);
                        if (btn) {
                            btn.disabled = false;
                            btn.textContent = btn.textContent.replace('æµ‹è¯•', 'æ¨¡æ‹Ÿæµ‹è¯•');
                        }
                    });
                    
                    // è¿è¡ŒåŸºç¡€éªŒè¯æµ‹è¯•
                    this.log('ğŸ” å¼€å§‹åŸºç¡€APIéªŒè¯...', 'info');
                    await this.runMockApiValidation();
                    
                    this.log('âœ… æ¨¡æ‹Ÿæµ‹è¯•ç¯å¢ƒå‡†å¤‡å®Œæˆï¼', 'success');
                    this.log('ğŸ’¡ ç°åœ¨å¯ä»¥ç‚¹å‡»å„ä¸ªæµ‹è¯•æŒ‰é’®è¿›è¡Œæ¨¡æ‹Ÿæµ‹è¯•', 'info');
                    
                } catch (error) {
                    this.log(`âŒ æ¨¡æ‹Ÿæµ‹è¯•åˆå§‹åŒ–å¤±è´¥: ${error.message}`, 'error');
                }
            }
            
            async runMockApiValidation() {
                this.log('ğŸ” éªŒè¯ esptool-js API å¯ç”¨æ€§...', 'info');
                
                                 // éªŒè¯ESPLoaderæ„é€ 
                 try {
                     const mockTransport = {
                         device: null,
                         baudrate: 115200,
                         connect: async () => {},
                         disconnect: async () => {},
                         write: async () => {},
                         read: async function*() {},
                         setRTS: async () => {},
                         setDTR: async () => {},
                         getInfo: () => "Mock Serial Port",
                         waitForUnlock: async () => {},
                         slip_writer: async () => {},
                         slip_reader: async function*() {},
                         checksum: () => 0,
                         trace: false,
                         traceLog: []
                     };
                    
                    const testLoader = new window.esptooljs.ESPLoader({
                        transport: mockTransport,
                        baudrate: 115200,
                        terminal: {
                            clean: () => {},
                            writeLine: (data) => this.log(`[Mock esptool.js] ${data}`, 'debug'),
                            write: (data) => this.log(`[Mock esptool.js] ${data}`, 'debug')
                        },
                        debugLogging: true
                    });
                    
                    this.log('âœ… ESPLoader API éªŒè¯æˆåŠŸ', 'success');
                    
                    // éªŒè¯ä¸»è¦æ–¹æ³•å­˜åœ¨æ€§
                    const methods = ['main', 'connect', 'detectChip', 'readReg', 'writeReg', 'sync'];
                    const missingMethods = methods.filter(method => typeof testLoader[method] !== 'function');
                    
                    if (missingMethods.length === 0) {
                        this.log('âœ… æ‰€æœ‰æ ¸å¿ƒæ–¹æ³•éªŒè¯é€šè¿‡', 'success');
                    } else {
                        this.log(`âš ï¸ ç¼ºå¤±æ–¹æ³•: ${missingMethods.join(', ')}`, 'warning');
                    }
                    
                    // éªŒè¯é‡ç½®ç­–ç•¥
                    const resetClasses = ['ClassicReset', 'HardReset', 'UsbJtagSerialReset', 'CustomReset'];
                    const availableResets = resetClasses.filter(cls => window.esptooljs[cls]);
                    this.log(`âœ… å¯ç”¨é‡ç½®ç­–ç•¥: ${availableResets.join(', ')}`, 'success');
                    
                    // éªŒè¯å·¥å…·å‡½æ•°
                    const utilFunctions = ['validateCustomResetStringSequence', 'inflate', 'deflate'];
                    const availableUtils = utilFunctions.filter(func => window.esptooljs[func]);
                    this.log(`âœ… å¯ç”¨å·¥å…·å‡½æ•°: ${availableUtils.join(', ')}`, 'success');
                    
                } catch (error) {
                    this.log(`âŒ API éªŒè¯å¤±è´¥: ${error.message}`, 'error');
                    this.log(`âŒ é”™è¯¯è¯¦æƒ…: ${error.stack}`, 'debug');
                    throw error;
                }
            }

            clearLog() {
                document.getElementById('debugLog').textContent = '';
                this.log('æ—¥å¿—å·²æ¸…ç©º', 'info');
            }

            exportLog() {
                const logContent = document.getElementById('debugLog').textContent;
                const blob = new Blob([logContent], { type: 'text/plain' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `esp32-test-log-${new Date().toISOString().slice(0,10)}.txt`;
                a.click();
                URL.revokeObjectURL(url);
                this.log('æ—¥å¿—å·²å¯¼å‡º', 'success');
            }
        }

        // å¯åŠ¨æµ‹è¯•å™¨
        console.log('ğŸ” [DEBUG] Creating ESP32CompleteTester instance...');
        try {
            const tester = new ESP32CompleteTester();
            console.log('âœ… [DEBUG] ESP32CompleteTester instance created successfully:', tester);
            console.log('ğŸ” [DEBUG] Tester methods available:', Object.getOwnPropertyNames(tester.__proto__));
            
            // æ£€æŸ¥æµè§ˆå™¨å…¼å®¹æ€§
            if (!('serial' in navigator)) {
                tester.log('æ­¤æµè§ˆå™¨ä¸æ”¯æŒWeb Serial API', 'error');
                tester.updateStatus('æµè§ˆå™¨ä¸æ”¯æŒWeb Serial API', 'error');
            } else {
                tester.log('æµè§ˆå™¨æ”¯æŒWeb Serial APIï¼Œå‡†å¤‡å°±ç»ª', 'success');
            }
            
            // æ‰‹åŠ¨æµ‹è¯•æŒ‰é’®ç‚¹å‡»åŠŸèƒ½
            setTimeout(() => {
                console.log('ğŸ” [DEBUG] === æŒ‰é’®çŠ¶æ€æ£€æŸ¥ ===');
                const connectBtn = document.getElementById('connectBtn');
                if (connectBtn) {
                    console.log('âœ… [DEBUG] Connect button found:', connectBtn);
                    console.log('ğŸ” [DEBUG] Connect button onclick:', connectBtn.onclick);
                    console.log('ğŸ” [DEBUG] Connect button disabled:', connectBtn.disabled);
                    console.log('ğŸ” [DEBUG] Connect button style.display:', connectBtn.style.display);
                    console.log('ğŸ” [DEBUG] Connect button offsetParent:', connectBtn.offsetParent);
                    
                    // æµ‹è¯•æ‰‹åŠ¨è§¦å‘ç‚¹å‡»
                    console.log('ğŸ” [DEBUG] Testing manual click trigger...');
                    connectBtn.onclick && connectBtn.onclick();
                    
                } else {
                    console.error('âŒ [DEBUG] Connect button not found!');
                }
                
                // æ£€æŸ¥å…¶ä»–æŒ‰é’®
                ['testBasicBtn', 'testDataBtn', 'clearLogBtn'].forEach(id => {
                    const btn = document.getElementById(id);
                    console.log(`ğŸ” [DEBUG] Button ${id}:`, btn ? 'âœ… Found' : 'âŒ Not found');
                    if (btn) {
                        console.log(`ğŸ” [DEBUG] ${id} onclick:`, btn.onclick);
                        console.log(`ğŸ” [DEBUG] ${id} disabled:`, btn.disabled);
                    }
                });
            }, 1000);
            
        } catch (error) {
            console.error('âŒ [DEBUG] Failed to create ESP32CompleteTester:', error);
            console.error('âŒ [DEBUG] Error stack:', error.stack);
        }
        
        // é¡µé¢åŠ è½½äº‹ä»¶æ£€æŸ¥
        document.addEventListener('DOMContentLoaded', () => {
            console.log('ğŸ” [DEBUG] DOMContentLoaded event fired');
        });
        
        window.addEventListener('load', () => {
            console.log('ğŸ” [DEBUG] Window load event fired');
        });
    </script>
</body>
</html> 