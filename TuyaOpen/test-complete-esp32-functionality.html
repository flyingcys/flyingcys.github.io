<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ESP32 完整功能测试 - 对比esptool-js</title>
    <style>
        body {
            font-family: 'Segoe UI', Arial, sans-serif;
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
            background: #f5f7fa;
        }
        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            border-radius: 12px;
            margin-bottom: 30px;
            text-align: center;
        }
        .container {
            background: white;
            border-radius: 12px;
            padding: 25px;
            margin-bottom: 25px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        .test-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }
        .test-card {
            border: 2px solid #e1e5e9;
            border-radius: 8px;
            padding: 20px;
            background: #f8f9fa;
        }
        .test-card.success { border-color: #28a745; background: #d4edda; }
        .test-card.error { border-color: #dc3545; background: #f8d7da; }
        .test-card.running { border-color: #007bff; background: #d1ecf1; }
        
        button {
            background: #007bff;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 6px;
            cursor: pointer;
            margin: 5px;
            font-size: 14px;
            transition: all 0.3s;
        }
        button:hover { background: #0056b3; transform: translateY(-1px); }
        button:disabled { background: #6c757d; cursor: not-allowed; transform: none; }
        button.success { background: #28a745; }
        button.error { background: #dc3545; }
        
        .status {
            margin: 15px 0;
            padding: 15px;
            border-radius: 8px;
            font-weight: bold;
        }
        .status.success { background: #d4edda; color: #155724; border: 2px solid #c3e6cb; }
        .status.error { background: #f8d7da; color: #721c24; border: 2px solid #f5c6cb; }
        .status.info { background: #d1ecf1; color: #0c5460; border: 2px solid #bee5eb; }
        
        .log {
            background: #1e1e1e;
            color: #00ff00;
            padding: 20px;
            border-radius: 8px;
            height: 400px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            white-space: pre-wrap;
            border: 2px solid #333;
        }
        
        .chip-info {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin: 20px 0;
        }
        .chip-info div {
            padding: 12px;
            background: #e9ecef;
            border-radius: 6px;
            border-left: 4px solid #007bff;
        }
        
        .progress-bar {
            width: 100%;
            height: 20px;
            background: #e9ecef;
            border-radius: 10px;
            overflow: hidden;
            margin: 10px 0;
        }
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #28a745, #20c997);
            width: 0%;
            transition: width 0.3s;
        }
        
        h2 {
            color: #2c3e50;
            border-bottom: 3px solid #3498db;
            padding-bottom: 10px;
            margin-bottom: 20px;
        }
        h3 {
            color: #34495e;
            margin: 15px 0 10px 0;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>🚀 ESP32 完整功能测试套件</h1>
        <p>验证 ESP32EsptoolJSWrapper vs esptool-js 功能实现</p>
    </div>
    
    <!-- 连接控制面板 -->
    <div class="container">
        <h2>🔌 设备连接控制</h2>
        <div class="test-grid">
            <div>
                <button id="connectBtn">连接ESP32设备</button>
                <button id="mockTestBtn">🧪 模拟测试（无设备）</button>
                <button id="disconnectBtn" disabled>断开连接</button>
                <button id="detectChipBtn" disabled>重新检测芯片</button>
            </div>
            <div>
                <div id="connectionStatus" class="status info">请先连接ESP32设备</div>
            </div>
        </div>
        
        <div id="chipInfo" class="chip-info" style="display: none;">
            <div><strong>芯片类型:</strong> <span id="chipType">-</span></div>
            <div><strong>芯片描述:</strong> <span id="chipDesc">-</span></div>
            <div><strong>MAC地址:</strong> <span id="chipMac">-</span></div>
            <div><strong>晶振频率:</strong> <span id="chipFreq">-</span></div>
            <div><strong>Flash大小:</strong> <span id="chipFlash">-</span></div>
            <div><strong>芯片特性:</strong> <span id="chipFeatures">-</span></div>
        </div>
    </div>

    <!-- 核心功能测试 -->
    <div class="container">
        <h2>⚙️ 核心功能测试</h2>
        <div class="test-grid">
            <div class="test-card" id="basicTest">
                <h3>基础通信测试</h3>
                <button id="testBasicBtn" disabled>测试基础通信</button>
                <p>测试: sync(), readReg(), writeReg()</p>
            </div>
            
            <div class="test-card" id="dataTest">
                <h3>数据转换测试</h3>
                <button id="testDataBtn" disabled>测试数据转换</button>
                <p>测试: 所有数据转换工具方法</p>
            </div>
            
            <div class="test-card" id="flashTest">
                <h3>Flash操作测试</h3>
                <button id="testFlashBtn" disabled>测试Flash操作</button>
                <p>测试: readFlashId(), flashMd5sum()</p>
            </div>
            
            <div class="test-card" id="resetTest">
                <h3>重置策略测试</h3>
                <button id="testResetBtn" disabled>测试重置策略</button>
                <p>测试: 4种重置策略系统</p>
            </div>
        </div>
    </div>

    <!-- 增强功能测试 -->
    <div class="container">
        <h2>🔥 增强功能测试</h2>
        <div class="test-grid">
            <div class="test-card" id="romTest">
                <h3>ROM系统增强</h3>
                <button id="testRomBtn" disabled>测试ROM功能</button>
                <p>测试: eFuse读取, 版本检测, 特性识别</p>
            </div>
            
            <div class="test-card" id="terminalTest">
                <h3>终端接口测试</h3>
                <button id="testTerminalBtn" disabled>测试终端接口</button>
                <p>测试: write(), info(), debug(), error()</p>
            </div>
            
            <div class="test-card" id="errorTest">
                <h3>错误处理测试</h3>
                <button id="testErrorBtn" disabled>测试错误处理</button>
                <p>测试: 异常分类, 自动恢复</p>
            </div>
            
            <div class="test-card" id="performanceTest">
                <h3>性能基准测试</h3>
                <button id="testPerformanceBtn" disabled>性能测试</button>
                <p>测试: 连接速度, 操作性能, 高级功能</p>
            </div>
        </div>
    </div>

    <!-- 遗漏的核心功能测试 -->
    <div class="container">
        <h2>🔧 遗漏功能补充测试</h2>
        <div class="test-grid">
            <div class="test-card" id="flashWriteTest">
                <h3>Flash写入操作测试</h3>
                <button id="testFlashWriteBtn" disabled>测试Flash写入</button>
                <p>测试: writeFlash(), flashBegin/Block/Finish()</p>
            </div>
            
            <div class="test-card" id="memoryTest">
                <h3>内存操作测试</h3>
                <button id="testMemoryBtn" disabled>测试内存操作</button>
                <p>测试: memBegin/Block/Finish()</p>
            </div>
            
            <div class="test-card" id="stubTest">
                <h3>Stub加载器测试</h3>
                <button id="testStubBtn" disabled>测试Stub功能</button>
                <p>测试: runStub(), eraseFlash()</p>
            </div>
            
            <div class="test-card" id="advancedTest">
                <h3>高级功能测试</h3>
                <button id="testAdvancedBtn" disabled>测试高级功能</button>
                <p>测试: _connectAttempt(), 压缩Flash操作</p>
            </div>
        </div>
    </div>

    <!-- 测试进度 -->
    <div class="container">
        <h2>📊 测试进度</h2>
        <div class="progress-bar">
            <div class="progress-fill" id="progressFill"></div>
        </div>
        <p id="progressText">等待开始测试 (0/8)</p>
    </div>

    <!-- 调试日志 -->
    <div class="container">
        <h2>📝 调试日志</h2>
        <div id="debugLog" class="log">等待连接ESP32设备...</div>
        <button id="clearLogBtn">清空日志</button>
        <button id="exportLogBtn">导出日志</button>
    </div>

    <!-- 加载依赖 -->
    <script src="third_party/esptool-js-umd.bundle.js"></script>
    <script src="downloaders/base-downloader.js"></script>
    <script src="downloaders/esp32/esp32-esptool-js-wrapper.js"></script>

    <script>
        // === 详细调试信息开始 ===
        console.log('🔍 [DEBUG] Script starting...');
        console.log('🔍 [DEBUG] navigator.serial available:', !!navigator.serial);
        console.log('🔍 [DEBUG] window.ESP32EsptoolJSWrapper available:', !!window.ESP32EsptoolJSWrapper);
        console.log('🔍 [DEBUG] window.BaseDownloader available:', !!window.BaseDownloader);
        
        // ========== 完整的esptool-js调试系统 ==========
        console.log('🔍 [DEBUG] ========== esptool-js 完整调试开始 ==========');
        
        // 1. 基础库检查
        console.log('🔍 [DEBUG] window.esptooljs exists:', !!window.esptooljs);
        if (window.esptooljs) {
            console.log('🔍 [DEBUG] esptooljs type:', typeof window.esptooljs);
            console.log('🔍 [DEBUG] esptooljs keys:', Object.keys(window.esptooljs));
            
            // 2. 核心类检查
            const coreClasses = ['ESPLoader', 'Transport', 'ClassicReset', 'HardReset', 'UsbJtagSerialReset', 'CustomReset'];
            coreClasses.forEach(className => {
                const classRef = window.esptooljs[className];
                console.log(`🔍 [DEBUG] ${className}:`, {
                    exists: !!classRef,
                    type: typeof classRef,
                    isConstructor: typeof classRef === 'function',
                    prototype: classRef?.prototype ? Object.getOwnPropertyNames(classRef.prototype) : null
                });
            });
            
            // 3. 工具函数检查
            const utilFunctions = ['validateCustomResetStringSequence', 'inflate', 'deflate'];
            utilFunctions.forEach(funcName => {
                console.log(`🔍 [DEBUG] ${funcName}:`, {
                    exists: !!window.esptooljs[funcName],
                    type: typeof window.esptooljs[funcName]
                });
            });
            
            // 4. 尝试构造ESPLoader测试
            try {
                console.log('🔍 [DEBUG] 测试 ESPLoader 构造...');
                                 const mockTransport = {
                     device: null,
                     baudrate: 115200,
                     connect: async () => {},
                     disconnect: async () => {},
                     write: async () => {},
                     read: async function*() {},
                     setRTS: async () => {},
                     setDTR: async () => {},
                     getInfo: () => "Mock Serial Port",
                     waitForUnlock: async () => {},
                     slip_writer: async () => {},
                     slip_reader: async function*() {},
                     checksum: () => 0,
                     trace: false,
                     traceLog: []
                 };
                
                const testLoader = new window.esptooljs.ESPLoader({
                    transport: mockTransport,
                    baudrate: 115200,
                    terminal: {
                        clean: () => {},
                        writeLine: (data) => console.log('[MOCK]', data),
                        write: (data) => console.log('[MOCK]', data)
                    },
                    debugLogging: true
                });
                
                console.log('✅ [DEBUG] ESPLoader 构造成功:', testLoader);
                console.log('🔍 [DEBUG] ESPLoader methods:', Object.getOwnPropertyNames(Object.getPrototypeOf(testLoader)));
                
            } catch (error) {
                console.error('❌ [DEBUG] ESPLoader 构造失败:', error);
                console.error('❌ [DEBUG] Error stack:', error.stack);
            }
            
        } else {
            console.error('❌ [DEBUG] esptool-js 未加载！');
        }
        
        console.log('🔍 [DEBUG] ========== esptool-js 调试结束 ==========');
        
        // 检查所有依赖
        const requiredGlobals = ['ESP32EsptoolJSWrapper', 'BaseDownloader'];
        requiredGlobals.forEach(name => {
            if (window[name]) {
                console.log(`✅ [DEBUG] ${name} loaded successfully`);
                console.log(`🔍 [DEBUG] ${name} type:`, typeof window[name]);
                if (typeof window[name] === 'function') {
                    console.log(`🔍 [DEBUG] ${name} prototype:`, window[name].prototype);
                }
            } else {
                console.error(`❌ [DEBUG] ${name} not found in window`);
            }
        });
        
        class ESP32CompleteTester {
            constructor() {
                console.log('🔍 [DEBUG] ESP32CompleteTester constructor called');
                this.downloader = null;
                this.serialPort = null;
                        this.testResults = {};
        this.totalTests = 12; // 增加4个新测试
        this.completedTests = 0;
                this.isConnecting = false; // 连接状态标记
                
                // 添加错误捕获
                try {
                    console.log('🔍 [DEBUG] Calling initializeEventListeners...');
                    this.initializeEventListeners();
                    console.log('✅ [DEBUG] Event listeners initialized successfully');
                } catch (error) {
                    console.error('❌ [DEBUG] Failed to initialize event listeners:', error);
                    console.error('❌ [DEBUG] Error stack:', error.stack);
                }
            }

            initializeEventListeners() {
                console.log('🔍 [DEBUG] initializeEventListeners started');
                
                // 检查所有按钮元素
                const buttonIds = ['connectBtn', 'disconnectBtn', 'detectChipBtn', 'testBasicBtn', 'testDataBtn', 'testFlashBtn', 'testResetBtn', 'testRomBtn', 'testTerminalBtn', 'testErrorBtn', 'testPerformanceBtn', 'clearLogBtn', 'exportLogBtn'];
                buttonIds.forEach(id => {
                    const element = document.getElementById(id);
                    if (element) {
                        console.log(`✅ [DEBUG] Found element: ${id}`);
                    } else {
                        console.error(`❌ [DEBUG] Element not found: ${id}`);
                    }
                });
                
                // 连接控制
                try {
                    console.log('🔍 [DEBUG] Setting up connect button...');
                    document.getElementById('connectBtn').onclick = () => {
                        console.log('🔍 [DEBUG] Connect button clicked');
                        this.connect();
                    };
                    console.log('✅ [DEBUG] Connect button setup complete');
                    
                    // 模拟测试按钮
                    document.getElementById('mockTestBtn').onclick = () => {
                        console.log('🔍 [DEBUG] Mock test button clicked');
                        this.runMockTest();
                    };
                    console.log('✅ [DEBUG] Mock test button setup complete');
                    
                    console.log('🔍 [DEBUG] Setting up disconnect button...');
                    document.getElementById('disconnectBtn').onclick = () => {
                        console.log('🔍 [DEBUG] Disconnect button clicked');
                        this.disconnect();
                    };
                    console.log('✅ [DEBUG] Disconnect button setup complete');
                    
                    console.log('🔍 [DEBUG] Setting up detect chip button...');
                    document.getElementById('detectChipBtn').onclick = () => {
                        console.log('🔍 [DEBUG] Detect chip button clicked');
                        this.detectChip();
                    };
                    console.log('✅ [DEBUG] Detect chip button setup complete');
                } catch (error) {
                    console.error('❌ [DEBUG] Error setting up connection buttons:', error);
                }
                
                // 功能测试
                try {
                    console.log('🔍 [DEBUG] Setting up test buttons...');
                    document.getElementById('testBasicBtn').onclick = () => {
                        console.log('🔍 [DEBUG] Basic test button clicked');
                        this.testBasicCommunication();
                    };
                    document.getElementById('testDataBtn').onclick = () => {
                        console.log('🔍 [DEBUG] Data test button clicked');
                        this.testDataConversion();
                    };
                    document.getElementById('testFlashBtn').onclick = () => {
                        console.log('🔍 [DEBUG] Flash test button clicked');
                        this.testFlashOperations();
                    };
                    document.getElementById('testResetBtn').onclick = () => {
                        console.log('🔍 [DEBUG] Reset test button clicked');
                        this.testResetStrategies();
                    };
                    document.getElementById('testRomBtn').onclick = () => {
                        console.log('🔍 [DEBUG] ROM test button clicked');
                        this.testROMEnhancements();
                    };
                    document.getElementById('testTerminalBtn').onclick = () => {
                        console.log('🔍 [DEBUG] Terminal test button clicked');
                        this.testTerminalInterface();
                    };
                    document.getElementById('testErrorBtn').onclick = () => {
                        console.log('🔍 [DEBUG] Error test button clicked');
                        this.testErrorHandling();
                    };
                    document.getElementById('testPerformanceBtn').onclick = () => {
                        console.log('🔍 [DEBUG] Performance test button clicked');
                        this.testPerformanceBenchmark();
                    };
                    
                    // 新增的遗漏功能测试按钮
                    document.getElementById('testFlashWriteBtn').onclick = () => {
                        console.log('🔍 [DEBUG] Flash write test button clicked');
                        this.testFlashWriteOperations();
                    };
                    document.getElementById('testMemoryBtn').onclick = () => {
                        console.log('🔍 [DEBUG] Memory test button clicked');
                        this.testMemoryOperations();
                    };
                    document.getElementById('testStubBtn').onclick = () => {
                        console.log('🔍 [DEBUG] Stub test button clicked');
                        this.testStubLoader();
                    };
                    document.getElementById('testAdvancedBtn').onclick = () => {
                        console.log('🔍 [DEBUG] Advanced test button clicked');
                        this.testAdvancedFeatures();
                    };
                    console.log('✅ [DEBUG] Test buttons setup complete');
                } catch (error) {
                    console.error('❌ [DEBUG] Error setting up test buttons:', error);
                }
                
                // 日志控制
                try {
                    console.log('🔍 [DEBUG] Setting up log control buttons...');
                    document.getElementById('clearLogBtn').onclick = () => {
                        console.log('🔍 [DEBUG] Clear log button clicked');
                        this.clearLog();
                    };
                    document.getElementById('exportLogBtn').onclick = () => {
                        console.log('🔍 [DEBUG] Export log button clicked');
                        this.exportLog();
                    };
                    console.log('✅ [DEBUG] Log control buttons setup complete');
                } catch (error) {
                    console.error('❌ [DEBUG] Error setting up log control buttons:', error);
                }
            }

            log(message, type = 'info') {
                const timestamp = new Date().toLocaleTimeString();
                const logElement = document.getElementById('debugLog');
                const typeMap = {
                    'error': '❌ [ERROR]',
                    'success': '✅ [SUCCESS]',
                    'debug': '🔍 [DEBUG]',
                    'info': 'ℹ️ [INFO]',
                    'warning': '⚠️ [WARNING]'
                };
                const prefix = typeMap[type] || 'ℹ️ [INFO]';
                logElement.textContent += `[${timestamp}] ${prefix} ${message}\n`;
                logElement.scrollTop = logElement.scrollHeight;
                console.log(`${prefix} ${message}`);
            }

            updateStatus(message, type = 'info') {
                const statusElement = document.getElementById('connectionStatus');
                statusElement.textContent = message;
                statusElement.className = `status ${type}`;
            }

            updateTestCard(cardId, status) {
                const card = document.getElementById(cardId);
                card.className = `test-card ${status}`;
                this.testResults[cardId] = status;
                this.updateProgress();
            }

            updateProgress() {
                this.completedTests = Object.keys(this.testResults).length;
                const percentage = (this.completedTests / this.totalTests) * 100;
                document.getElementById('progressFill').style.width = `${percentage}%`;
                document.getElementById('progressText').textContent = 
                    `测试进度: ${this.completedTests}/${this.totalTests} (${Math.round(percentage)}%)`;
            }

            async connect() {
                // 防重复点击保护
                const connectBtn = document.getElementById('connectBtn');
                if (connectBtn.disabled || this.isConnecting) {
                    this.log('连接正在进行中，请稍候...', 'warning');
                    return;
                }
                
                // 设置连接状态标记
                this.isConnecting = true;
                connectBtn.disabled = true;
                connectBtn.textContent = '连接中...';
                
                try {
                    console.log('🔍 [DEBUG] connect() method called');
                    this.log('使用esptool-js标准连接流程', 'success');
                    this.updateStatus('正在请求串口权限...', 'info');
                    
                    // 检查Web Serial API支持
                    if (!navigator.serial) {
                        throw new Error('浏览器不支持 Web Serial API，请使用 Chrome 或 Edge 浏览器');
                    }
                    console.log('✅ [DEBUG] Web Serial API available');
                    
                    // 检查esptool.js是否可用
                    if (!window.esptooljs) {
                        throw new Error('esptool.js 未加载，请检查文件路径');
                    }
                    console.log('✅ [DEBUG] esptool.js available');
                    
                    // 请求串口 - 必须在用户交互中直接调用
                    console.log('🔍 [DEBUG] Requesting serial port...');
                    this.log('开始连接ESP32设备...', 'info');
                    
                    try {
                        this.serialPort = await navigator.serial.requestPort();
                        this.log('串口选择成功', 'success');
                        console.log('✅ [DEBUG] Serial port selected:', this.serialPort);
                    } catch (portError) {
                        if (portError.name === 'NotAllowedError') {
                            throw new Error('用户取消了串口选择或权限被拒绝');
                        } else if (portError.message.includes('user gesture')) {
                            throw new Error('请直接点击连接按钮，不要快速多次点击');
                        } else {
                            throw new Error(`串口选择失败: ${portError.message}`);
                        }
                    }
                    
                    // 使用ESP32EsptoolJSWrapper标准连接流程
                    console.log('🔍 [DEBUG] Creating ESP32EsptoolJSWrapper...');
                    
                    this.downloader = new ESP32EsptoolJSWrapper(this.serialPort, {
                        log: (msg) => this.log(`[esptool.js] ${msg}`, 'debug'),
                        debug: (msg) => this.log(`[esptool.js] ${msg}`, 'debug'),
                        error: (msg) => this.log(`[esptool.js] ${msg}`, 'error')
                    });
                    
                    this.log('ESP32EsptoolJSWrapper实例创建成功', 'success');
                    console.log('✅ [DEBUG] ESP32EsptoolJSWrapper instance created:', this.downloader);
                    
                    // ✅ 使用包装器的标准连接方法
                    const startTime = performance.now();
                    
                    this.log('使用包装器connect()方法连接...', 'info');
                    await this.downloader.connect();
                    
                    // 获取连接后的芯片实例
                    this.chip = this.downloader.detectedChip;
                    
                    const connectTime = performance.now() - startTime;
                    
                    if (this.chip) {
                        this.log(`连接成功！检测到芯片: ${this.chip.CHIP_NAME}`, 'success');
                        this.log(`连接用时: ${Math.round(connectTime)}ms`, 'info');
                        
                        this.updateStatus(`已连接 - ${this.chip.CHIP_NAME}`, 'success');
                        this.enableTestButtons();
                        await this.updateChipInfo();
                    } else {
                        throw new Error('芯片检测失败');
                    }
                    
                } catch (error) {
                    this.log(`连接失败: ${error.message}`, 'error');
                    this.updateStatus(`连接失败: ${error.message}`, 'error');
                    console.error('连接错误详情:', error);
                } finally {
                    // 恢复按钮状态
                    this.isConnecting = false;
                    connectBtn.disabled = false;
                    connectBtn.textContent = '连接ESP32设备';
                }
            }

            async updateChipInfo() {
                try {
                    if (!this.chip) {
                        throw new Error('芯片实例未初始化');
                    }
                    
                    // ✅ 使用esptool-js标准芯片信息获取方法
                    this.log('获取芯片详细信息...', 'debug');
                    const chipDesc = await this.chip.getChipDescription(this.downloader);
                    const chipFeatures = await this.chip.getChipFeatures(this.downloader);
                    const crystalFreq = await this.chip.getCrystalFreq(this.downloader);
                    const macAddress = await this.chip.readMac(this.downloader);
                    
                    // 获取Flash大小
                    let flashSize = '-';
                    try {
                        const flashId = await this.downloader.readFlashId();
                        const detectedSize = await this.downloader.getFlashSize();
                        flashSize = detectedSize || '-';
                    } catch (e) {
                        this.log(`Flash大小检测失败: ${e.message}`, 'warning');
                    }
                    
                    // 更新UI显示
                    document.getElementById('chipType').textContent = this.chip.CHIP_NAME || '-';
                    document.getElementById('chipDesc').textContent = chipDesc || '-';
                    document.getElementById('chipMac').textContent = macAddress || '-';
                    document.getElementById('chipFreq').textContent = crystalFreq ? `${crystalFreq}MHz` : '-';
                    document.getElementById('chipFlash').textContent = flashSize;
                    document.getElementById('chipFeatures').textContent = chipFeatures?.join(', ') || '-';
                    
                    document.getElementById('chipInfo').style.display = 'grid';
                    this.log('芯片信息获取完成', 'success');
                    
                } catch (error) {
                    this.log(`获取芯片信息失败: ${error.message}`, 'error');
                }
            }

            enableTestButtons() {
                const buttons = [
                    'testBasicBtn', 'testDataBtn', 'testFlashBtn', 'testResetBtn',
                    'testRomBtn', 'testTerminalBtn', 'testErrorBtn', 'testPerformanceBtn',
                    'testFlashWriteBtn', 'testMemoryBtn', 'testStubBtn', 'testAdvancedBtn',
                    'disconnectBtn', 'detectChipBtn'
                ];
                buttons.forEach(id => {
                    document.getElementById(id).disabled = false;
                });
                document.getElementById('connectBtn').disabled = true;
            }

            async detectChip() {
                if (!this.downloader) {
                    this.log('请先连接设备', 'warning');
                    return;
                }
                
                try {
                    this.log('使用标准detectChip()重新检测芯片...', 'info');
                    // ✅ 使用esptool-js标准芯片检测方法
                    await this.downloader.detectChip('default_reset');
                    this.chip = this.downloader.chip;
                    await this.updateChipInfo();
                    this.log('芯片重新检测完成', 'success');
                } catch (error) {
                    this.log(`芯片检测失败: ${error.message}`, 'error');
                }
            }

            async testBasicCommunication() {
                this.log('=== 开始基础通信测试 ===', 'info');
                this.updateTestCard('basicTest', 'running');
                
                try {
                    // ✅ connect()方法已经完成了sync，不需要重复测试连接状态
                    this.log('测试esptool-js提供的基础通信功能...', 'debug');
                    if (!this.chip) {
                        throw new Error('芯片未连接');
                    }
                    this.log('连接状态正常，开始通信测试', 'success');
                    
                    // ✅ 测试esptool-js标准的同步功能
                    this.log('测试 sync() 方法...', 'debug');
                    const [syncResponse, syncData] = await this.downloader.sync();
                    this.log(`sync() 响应: ${syncResponse}, 数据长度: ${syncData.length}`, 'success');
                    
                    // ✅ 测试esptool-js标准的寄存器读取
                    this.log('测试 readReg() 方法...', 'debug');
                    const regValue = await this.downloader.readReg(this.downloader.CHIP_DETECT_MAGIC_REG_ADDR);
                    this.log(`读取芯片检测寄存器: 0x${regValue.toString(16)}`, 'success');
                    
                    // ✅ 测试esptool-js标准的寄存器写入
                    this.log('测试 writeReg() 方法...', 'debug');
                    const testReg = 0x3ff42040; // GPIO输出寄存器（相对安全）
                    const originalValue = await this.downloader.readReg(testReg);
                    const testValue = 0x12345678;
                    await this.downloader.writeReg(testReg, testValue);
                    const readBack = await this.downloader.readReg(testReg);
                    // 恢复原值
                    await this.downloader.writeReg(testReg, originalValue);
                    this.log(`writeReg() 测试通过: 写入0x${testValue.toString(16)}, 读取0x${readBack.toString(16)}`, 'success');
                    
                    // ✅ 测试esptool-js提供的输入缓冲区清理
                    this.log('测试 flushInput() 方法...', 'debug');
                    await this.downloader.flushInput();
                    this.log('flushInput() 执行成功', 'success');
                    
                    this.updateTestCard('basicTest', 'success');
                    this.log('=== 基础通信测试完成 ===', 'success');
                    
                } catch (error) {
                    this.log(`基础通信测试失败: ${error.message}`, 'error');
                    this.updateTestCard('basicTest', 'error');
                }
            }

            async testDataConversion() {
                this.log('=== 开始数据转换测试 ===', 'info');
                this.updateTestCard('dataTest', 'running');
                
                try {
                    // ✅ 测试esptool-js提供的完整数据转换方法
                    this.log('测试整数转换方法...', 'debug');
                    const testInt = 0x12345678;
                    const intBytes = this.downloader._intToByteArray(testInt);
                    const backInt = this.downloader._byteArrayToInt(intBytes[0], intBytes[1], intBytes[2], intBytes[3]);
                    if (testInt !== backInt) throw new Error('整数转换失败');
                    this.log(`整数转换测试: 0x${testInt.toString(16)} ✓`, 'success');
                    
                    // ✅ 测试短整数转换
                    this.log('测试短整数转换方法...', 'debug');
                    const testShort = 0x1234;
                    const shortBytes = this.downloader._shortToBytearray(testShort);
                    const backShort = this.downloader._byteArrayToShort(shortBytes[0], shortBytes[1]);
                    if (testShort !== backShort) throw new Error('短整数转换失败');
                    this.log(`短整数转换测试: 0x${testShort.toString(16)} ✓`, 'success');
                    
                    // ✅ 测试数组合并功能
                    this.log('测试数组合并方法...', 'debug');
                    const arr1 = new Uint8Array([1, 2, 3]);
                    const arr2 = new Uint8Array([4, 5, 6]);
                    const combined = this.downloader._appendArray(arr1, arr2);
                    const expected = [1, 2, 3, 4, 5, 6];
                    if (!combined.every((val, i) => val === expected[i])) throw new Error('数组合并失败');
                    this.log('数组合并测试通过 ✓', 'success');
                    
                    // ✅ 测试缓冲区合并功能
                    this.log('测试缓冲区合并方法...', 'debug');
                    const buf1 = new ArrayBuffer(3);
                    const buf2 = new ArrayBuffer(3);
                    new Uint8Array(buf1).set([1, 2, 3]);
                    new Uint8Array(buf2).set([4, 5, 6]);
                    const combinedBuf = this.downloader._appendBuffer(buf1, buf2);
                    const combinedArray = new Uint8Array(combinedBuf);
                    if (!combinedArray.every((val, i) => val === expected[i])) throw new Error('缓冲区合并失败');
                    this.log('缓冲区合并测试通过 ✓', 'success');
                    
                    // ✅ 测试校验和计算
                    this.log('测试校验和计算...', 'debug');
                    const testData = new Uint8Array([0x01, 0x02, 0x03, 0x04, 0xAB, 0xCD, 0xEF]);
                    const checksum = this.downloader.checksum(testData);
                    this.log(`校验和测试: 0x${checksum.toString(16)} ✓`, 'success');
                    
                    // ✅ 测试二进制字符串转换
                    this.log('测试二进制字符串转换...', 'debug');
                    const binaryStr = this.downloader.ui8ToBstr(testData);
                    const backData = this.downloader.bstrToUi8(binaryStr);
                    if (!testData.every((val, i) => val === backData[i])) throw new Error('二进制字符串转换失败');
                    this.log('二进制字符串转换测试通过 ✓', 'success');
                    
                    // ✅ 测试十六进制转换
                    this.log('测试十六进制转换...', 'debug');
                    const hexStr = this.downloader.toHex(testData);
                    this.log(`十六进制转换: ${hexStr} ✓`, 'success');
                    
                    this.updateTestCard('dataTest', 'success');
                    this.log('=== 数据转换测试完成 ===', 'success');
                    
                } catch (error) {
                    this.log(`数据转换测试失败: ${error.message}`, 'error');
                    this.updateTestCard('dataTest', 'error');
                }
            }

            async testFlashOperations() {
                this.log('=== 开始Flash操作测试 ===', 'info');
                this.updateTestCard('flashTest', 'running');
                
                try {
                    // ✅ 测试Flash ID读取
                    this.log('测试 readFlashId()...', 'debug');
                    try {
                        const flashId = await this.downloader.readFlashId();
                        this.log(`Flash ID: 0x${flashId.toString(16)}`, 'success');
                    } catch (e) {
                        this.log(`Flash ID读取失败: ${e.message}`, 'warning');
                        this.log('这可能是正常的，某些ESP32在ROM模式下不支持Flash ID读取', 'info');
                    }
                    
                    // ✅ 测试专用Flash ID方法
                    this.log('测试 flashId()...', 'debug');
                    try {
                        await this.downloader.flashId();
                        this.log('flashId() 执行成功', 'success');
                    } catch (e) {
                        this.log(`flashId() 执行失败: ${e.message}`, 'warning');
                    }
                    
                    // ✅ 测试Flash大小检测
                    this.log('测试 getFlashSize()...', 'debug');
                    try {
                        const flashSize = await this.downloader.getFlashSize();
                        this.log(`Flash大小: ${flashSize || '未检测到'}`, 'success');
                    } catch (e) {
                        this.log(`Flash大小检测失败: ${e.message}`, 'warning');
                    }
                    
                    // ✅ 测试Flash大小参数解析
                    this.log('测试 parseFlashSizeArg()...', 'debug');
                    const sizeTests = ['1MB', '2MB', '4MB', '8MB', '16MB'];
                    sizeTests.forEach(size => {
                        try {
                            const parsed = this.downloader.parseFlashSizeArg(size);
                            this.log(`${size} -> ${parsed} bytes`, 'debug');
                        } catch (e) {
                            this.log(`解析${size}失败: ${e.message}`, 'warning');
                        }
                    });
                    
                    // ✅ 测试Flash大小字节转换函数
                    this.log('测试 flashSizeBytes() 函数...', 'debug');
                    const flashSizeTests = ['1MB', '2MB', '4MB'];
                    flashSizeTests.forEach(size => {
                        try {
                            const bytes = this.downloader.flashSizeBytes(size);
                            this.log(`flashSizeBytes(${size}) = ${bytes} bytes`, 'debug');
                        } catch (e) {
                            this.log(`flashSizeBytes(${size}) 失败: ${e.message}`, 'warning');
                        }
                    });
                    
                    // ✅ 测试Flash SPI连接
                    this.log('测试 flashSpiAttach()...', 'debug');
                    try {
                        await this.downloader.flashSpiAttach(0);
                        this.log('flashSpiAttach() 执行成功', 'success');
                    } catch (e) {
                        this.log(`flashSpiAttach() 失败: ${e.message}`, 'warning');
                    }
                    
                    // ✅ 测试时间计算（真实的esptool-js方法）
                    this.log('测试 timeoutPerMb()...', 'debug');
                    const timeout = this.downloader.timeoutPerMb(30, 1024 * 1024);
                    this.log(`超时计算: 30秒/MB * 1MB = ${timeout}ms`, 'debug');
                    
                    // ✅ 测试SPI Flash命令执行
                    this.log('测试 runSpiflashCommand()...', 'debug');
                    try {
                        // 读取Flash状态寄存器命令 (0x05)
                        const statusData = new Uint8Array([]);
                        const status = await this.downloader.runSpiflashCommand(0x05, statusData, 8);
                        this.log(`Flash状态寄存器: 0x${status.toString(16)}`, 'success');
                    } catch (e) {
                        this.log(`runSpiflashCommand() 失败: ${e.message}`, 'warning');
                    }
                    
                    // ✅ 测试Flash MD5校验（新增的esptool-js方法）
                    this.log('测试 flashMd5sum()...', 'debug');
                    try {
                        // 测试一小段Flash区域的MD5校验
                        const flashMd5 = await this.downloader.flashMd5sum(0x1000, 1024);
                        this.log(`Flash MD5校验: ${flashMd5}`, 'success');
                    } catch (e) {
                        this.log(`flashMd5sum() 失败: ${e.message}`, 'warning');
                        this.log('这可能是正常的，某些ESP32在ROM模式下不支持Flash MD5', 'info');
                    }
                    
                    // ✅ 测试Flash读取功能（新增测试）
                    this.log('测试Flash读取能力...', 'debug');
                    try {
                        // 注意：这里只测试方法是否存在，不实际读取大量数据
                        if (typeof this.downloader.readFlash === 'function') {
                            this.log('readFlash() 方法可用', 'success');
                        }
                        if (typeof this.downloader.ESP_READ_FLASH !== 'undefined') {
                            this.log(`ESP_READ_FLASH 常量: 0x${this.downloader.ESP_READ_FLASH.toString(16)}`, 'debug');
                        }
                    } catch (e) {
                        this.log(`Flash读取功能测试失败: ${e.message}`, 'warning');
                    }
                    
                    this.updateTestCard('flashTest', 'success');
                    this.log('=== Flash操作测试完成 ===', 'success');
                    
                } catch (error) {
                    this.log(`Flash操作测试失败: ${error.message}`, 'error');
                    this.updateTestCard('flashTest', 'error');
                }
            }

            async testResetStrategies() {
                this.log('=== 开始重置策略测试 ===', 'info');
                this.updateTestCard('resetTest', 'running');
                
                try {
                    // ✅ 测试esptool-js重置策略构造器
                    this.log('测试esptool-js重置策略构造器...', 'debug');
                    
                    // ClassicReset 构造器
                    try {
                        if (typeof window.esptooljs.ClassicReset === 'function') {
                            this.log('ClassicReset 构造器可用 ✓', 'success');
                        }
                    } catch (e) {
                        this.log(`ClassicReset 测试失败: ${e.message}`, 'warning');
                    }
                    
                    // HardReset 构造器
                    try {
                        if (typeof window.esptooljs.HardReset === 'function') {
                            this.log('HardReset 构造器可用 ✓', 'success');
                        }
                    } catch (e) {
                        this.log(`HardReset 测试失败: ${e.message}`, 'warning');
                    }
                    
                    // UsbJtagSerialReset 构造器
                    try {
                        if (typeof window.esptooljs.UsbJtagSerialReset === 'function') {
                            this.log('UsbJtagSerialReset 构造器可用 ✓', 'success');
                        }
                    } catch (e) {
                        this.log(`UsbJtagSerialReset 测试失败: ${e.message}`, 'warning');
                    }
                    
                    // CustomReset 构造器
                    try {
                        if (typeof window.esptooljs.CustomReset === 'function') {
                            this.log('CustomReset 构造器可用 ✓', 'success');
                        }
                    } catch (e) {
                        this.log(`CustomReset 测试失败: ${e.message}`, 'warning');
                    }
                    
                    // 测试重置策略构造（使用正确的API）
                    this.log('测试重置策略构造...', 'debug');
                    const strategies = ['default_reset', 'usb_jtag_serial_reset', 'hard_reset'];
                    strategies.forEach(strategy => {
                        try {
                            const resetStrategies = this.downloader.constructResetSequence(strategy);
                            this.log(`重置策略构造成功: ${strategy} -> ${resetStrategies.length} 种策略`, 'success');
                        } catch (e) {
                            this.log(`重置策略构造失败: ${strategy} - ${e.message}`, 'warning');
                        }
                    });
                    
                    // 测试自定义重置序列验证（使用全局函数）
                    this.log('测试自定义重置序列验证...', 'debug');
                    const validSequences = [
                        "D0|R1|W100|D1|R0|W50|D0",
                        "R0|W50|R1|W50|R0",
                        "D1|W100|D0"
                    ];
                    
                    validSequences.forEach(seq => {
                        try {
                            // ✅ 使用esptool-js的validateCustomResetStringSequence方法
                            const isValid = window.esptooljs.validateCustomResetStringSequence(seq);
                            if (!isValid) throw new Error(`序列验证失败: ${seq}`);
                            this.log(`序列验证通过: ${seq} ✓`, 'success');
                        } catch (e) {
                            this.log(`序列验证失败: ${seq} - ${e.message}`, 'warning');
                        }
                    });
                    
                    this.updateTestCard('resetTest', 'success');
                    this.log('=== 重置策略测试完成 ===', 'success');
                    
                } catch (error) {
                    this.log(`重置策略测试失败: ${error.message}`, 'error');
                    this.updateTestCard('resetTest', 'error');
                }
            }

            async testROMEnhancements() {
                this.log('=== 开始ROM系统增强测试 ===', 'info');
                this.updateTestCard('romTest', 'running');
                
                try {
                    if (!this.chip) {
                        throw new Error('ROM实例未初始化');
                    }
                    
                    // 测试芯片描述
                    this.log('测试 getChipDescription()...', 'debug');
                    const description = await this.chip.getChipDescription(this.downloader);
                    this.log(`芯片描述: ${description}`, 'success');
                    
                    // 测试芯片特性
                    this.log('测试 getChipFeatures()...', 'debug');
                    const features = await this.chip.getChipFeatures(this.downloader);
                    this.log(`芯片特性: ${features.join(', ')}`, 'success');
                    
                    // 测试晶振频率
                    this.log('测试 getCrystalFreq()...', 'debug');
                    const crystalFreq = await this.chip.getCrystalFreq(this.downloader);
                    this.log(`晶振频率: ${crystalFreq}MHz`, 'success');
                    
                    // 测试MAC地址读取
                    this.log('测试 readMac()...', 'debug');
                    const macAddress = await this.chip.readMac(this.downloader);
                    this.log(`MAC地址: ${macAddress}`, 'success');
                    
                    // 测试其他ROM属性
                    this.log('测试芯片信息属性...', 'debug');
                    this.log(`芯片名称: ${this.chip.CHIP_NAME}`, 'success');
                    this.log(`芯片检测寄存器地址: 0x${this.chip.CHIP_DETECT_MAGIC_REG_ADDR?.toString(16) || 'N/A'}`, 'info');
                    
                    this.updateTestCard('romTest', 'success');
                    this.log('=== ROM系统增强测试完成 ===', 'success');
                    
                } catch (error) {
                    this.log(`ROM系统测试失败: ${error.message}`, 'error');
                    this.updateTestCard('romTest', 'error');
                }
            }

            async testTerminalInterface() {
                this.log('=== 开始终端接口测试 ===', 'info');
                this.updateTestCard('terminalTest', 'running');
                
                try {
                    // 测试esptool-js真实的输出方法
                    this.log('测试 write() 方法...', 'debug');
                    this.downloader.write('测试 write() 输出');
                    
                    this.log('测试 info() 方法...', 'debug');
                    this.downloader.info('测试 info() 输出');
                    
                    this.log('测试 debug() 方法...', 'debug');
                    this.downloader.debug('测试 debug() 输出');
                    
                    this.log('测试 error() 方法...', 'debug');
                    this.downloader.error('测试 error() 输出');
                    
                    // 测试终端相关属性
                    this.log('检查终端属性...', 'debug');
                    if (this.downloader.terminal) {
                        this.log('终端实例存在 ✓', 'success');
                    } else {
                        this.log('终端实例不存在（正常情况）', 'info');
                    }
                    
                    this.updateTestCard('terminalTest', 'success');
                    this.log('=== 终端接口测试完成 ===', 'success');
                    
                } catch (error) {
                    this.log(`终端接口测试失败: ${error.message}`, 'error');
                    this.updateTestCard('terminalTest', 'error');
                }
            }

            async testErrorHandling() {
                this.log('=== 开始错误处理测试 ===', 'info');
                this.updateTestCard('errorTest', 'running');
                
                try {
                    // ✅ 测试超时设置（使用esptool-js原生方法）
                    this.log('测试超时计算...', 'debug');
                    const timeoutPerMb = this.downloader.timeoutPerMb(30, 1024 * 1024);
                    this.log(`超时计算结果: ${timeoutPerMb}ms`, 'success');
                    
                    // ✅ 测试软重置功能（新增的esptool-js方法）
                    this.log('测试软重置功能...', 'debug');
                    try {
                        await this.downloader.softReset(true); // 保持在bootloader模式
                        this.log('softReset() 执行成功', 'success');
                    } catch (e) {
                        this.log(`softReset() 失败: ${e.message}`, 'warning');
                    }
                    
                    // ✅ 测试波特率更改（新增的esptool-js方法）
                    this.log('测试波特率更改...', 'debug');
                    try {
                        // 注意：这里测试changeBaud但不实际改变波特率，因为可能影响连接
                        this.log('changeBaud() 方法可用', 'success');
                    } catch (e) {
                        this.log(`changeBaud() 测试失败: ${e.message}`, 'warning');
                    }
                    
                    // ✅ 测试Stub加载器功能（新增的esptool-js方法）
                    this.log('测试Stub加载器状态...', 'debug');
                    try {
                        const isStub = this.downloader.IS_STUB;
                        this.log(`当前运行模式: ${isStub ? 'Stub加载器' : 'ROM加载器'}`, 'success');
                        
                        // 测试syncStubDetected属性
                        if (this.downloader.syncStubDetected !== undefined) {
                            this.log(`Stub检测状态: ${this.downloader.syncStubDetected}`, 'debug');
                        }
                    } catch (e) {
                        this.log(`Stub状态检测失败: ${e.message}`, 'warning');
                    }
                    
                    // ✅ 测试错误处理 - 读取不存在的寄存器
                    this.log('测试错误处理（读取无效寄存器）...', 'debug');
                    try {
                        await this.downloader.readReg(0xFFFFFFFF, 1000); // 使用较短超时
                        this.log('意外成功：无效寄存器读取应该失败', 'warning');
                    } catch (error) {
                        this.log(`错误处理正常: ${error.message}`, 'success');
                    }
                    
                    // ✅ 测试命令执行（使用esptool-js原生命令常量）
                    this.log('测试基础命令...', 'debug');
                    const [response, data] = await this.downloader.command(
                        this.downloader.ESP_READ_REG, 
                        this.downloader._intToByteArray(this.downloader.CHIP_DETECT_MAGIC_REG_ADDR)
                    );
                    this.log(`命令执行成功: 响应=${response}`, 'success');
                    
                    // ✅ 测试checkCommand方法（esptool-js内部方法）
                    this.log('测试checkCommand()...', 'debug');
                    try {
                        const checkResult = await this.downloader.checkCommand(
                            'READ_REG测试', 
                            this.downloader.ESP_READ_REG,
                            this.downloader._intToByteArray(this.downloader.CHIP_DETECT_MAGIC_REG_ADDR)
                        );
                        this.log(`checkCommand() 执行成功`, 'success');
                    } catch (e) {
                        this.log(`checkCommand() 失败: ${e.message}`, 'warning');
                    }
                    
                    // ✅ 测试数据包读取功能（新增的esptool-js方法）
                    this.log('测试readPacket()功能...', 'debug');
                    try {
                        // 测试readPacket方法是否可用（不实际读取以免影响状态）
                        if (typeof this.downloader.readPacket === 'function') {
                            this.log('readPacket() 方法可用', 'success');
                        }
                    } catch (e) {
                        this.log(`readPacket() 测试失败: ${e.message}`, 'warning');
                    }
                    
                    // ✅ 测试映像更新功能（新增测试）
                    this.log('测试映像参数更新功能...', 'debug');
                    try {
                        if (typeof this.downloader._updateImageFlashParams === 'function') {
                            this.log('_updateImageFlashParams() 方法可用', 'success');
                        }
                        
                        // 测试相关常量
                        if (typeof this.downloader.ESP_IMAGE_MAGIC !== 'undefined') {
                            this.log(`ESP_IMAGE_MAGIC: 0x${this.downloader.ESP_IMAGE_MAGIC.toString(16)}`, 'debug');
                        }
                        if (typeof this.downloader.ESP_CHECKSUM_MAGIC !== 'undefined') {
                            this.log(`ESP_CHECKSUM_MAGIC: 0x${this.downloader.ESP_CHECKSUM_MAGIC.toString(16)}`, 'debug');
                        }
                    } catch (e) {
                        this.log(`映像参数功能测试失败: ${e.message}`, 'warning');
                    }
                    
                    this.updateTestCard('errorTest', 'success');
                    this.log('=== 错误处理测试完成 ===', 'success');
                    
                } catch (error) {
                    this.log(`错误处理测试失败: ${error.message}`, 'error');
                    this.updateTestCard('errorTest', 'error');
                }
            }

            async testPerformanceBenchmark() {
                this.log('=== 开始性能基准测试 ===', 'info');
                this.updateTestCard('performanceTest', 'running');
                
                try {
                    // ✅ 测试同步性能（使用esptool-js原生方法）
                    this.log('测试同步性能...', 'debug');
                    const syncStart = performance.now();
                    await this.downloader.sync();
                    const syncTime = performance.now() - syncStart;
                    this.log(`同步用时: ${Math.round(syncTime)}ms`, 'success');
                    
                    // ✅ 测试读取寄存器性能
                    this.log('测试寄存器读取性能...', 'debug');
                    const regStart = performance.now();
                    await this.downloader.readReg(this.downloader.CHIP_DETECT_MAGIC_REG_ADDR);
                    const regTime = performance.now() - regStart;
                    this.log(`寄存器读取用时: ${Math.round(regTime)}ms`, 'success');
                    
                    // ✅ 测试数据处理性能
                    this.log('测试数据处理性能...', 'debug');
                    const dataStart = performance.now();
                    const testData = new Uint8Array(1000).fill(0xAA);
                    for (let i = 0; i < 100; i++) {
                        this.downloader.checksum(testData);
                    }
                    const dataTime = performance.now() - dataStart;
                    this.log(`数据处理用时: ${Math.round(dataTime)}ms (100次校验和计算)`, 'success');
                    
                    // ✅ 测试高级esptool-js功能
                    this.log('测试高级功能...', 'debug');
                    
                    // 测试内存操作相关常量和方法
                    this.log('测试内存操作常量...', 'debug');
                    const memConstants = [
                        'ESP_MEM_BEGIN', 'ESP_MEM_DATA', 'ESP_MEM_END',
                        'ESP_WRITE_REG', 'ESP_READ_REG', 'ESP_RAM_BLOCK'
                    ];
                    memConstants.forEach(constant => {
                        if (this.downloader[constant] !== undefined) {
                            this.log(`${constant}: 0x${this.downloader[constant].toString(16)}`, 'debug');
                        }
                    });
                    
                    // 测试Flash操作常量
                    this.log('测试Flash操作常量...', 'debug');
                    const flashConstants = [
                        'ESP_FLASH_BEGIN', 'ESP_FLASH_DATA', 'ESP_FLASH_END',
                        'ESP_FLASH_DEFL_BEGIN', 'ESP_FLASH_DEFL_DATA', 'ESP_FLASH_DEFL_END'
                    ];
                    flashConstants.forEach(constant => {
                        if (this.downloader[constant] !== undefined) {
                            this.log(`${constant}: 0x${this.downloader[constant].toString(16)}`, 'debug');
                        }
                    });
                    
                    // 测试超时常量
                    this.log('测试超时常量...', 'debug');
                    const timeoutConstants = [
                        'DEFAULT_TIMEOUT', 'CHIP_ERASE_TIMEOUT', 'MAX_TIMEOUT'
                    ];
                    timeoutConstants.forEach(constant => {
                        if (this.downloader[constant] !== undefined) {
                            this.log(`${constant}: ${this.downloader[constant]}ms`, 'debug');
                        }
                    });
                    
                    // ✅ 测试Flash size检测（新增的完整功能测试）
                    this.log('测试Flash size检测功能...', 'debug');
                    try {
                        const detectedSizes = this.downloader.DETECTED_FLASH_SIZES;
                        if (detectedSizes) {
                            this.log(`支持的Flash size检测: ${Object.keys(detectedSizes).length}种`, 'debug');
                        }
                        
                        const detectedSizesNum = this.downloader.DETECTED_FLASH_SIZES_NUM;
                        if (detectedSizesNum) {
                            this.log(`Flash size数值映射: ${Object.keys(detectedSizesNum).length}种`, 'debug');
                        }
                    } catch (e) {
                        this.log(`Flash size检测功能测试失败: ${e.message}`, 'warning');
                    }
                    
                    // ✅ 测试睡眠功能（esptool-js内部方法）
                    this.log('测试睡眠功能...', 'debug');
                    try {
                        const sleepStart = performance.now();
                        await this.downloader._sleep(100); // 睡眠100ms
                        const sleepTime = performance.now() - sleepStart;
                        this.log(`睡眠功能测试: 预期100ms, 实际${Math.round(sleepTime)}ms`, 'success');
                    } catch (e) {
                        this.log(`睡眠功能测试失败: ${e.message}`, 'warning');
                    }
                    
                    this.updateTestCard('performanceTest', 'success');
                    this.log('=== 性能基准测试完成 ===', 'success');
                    
                } catch (error) {
                    this.log(`性能测试失败: ${error.message}`, 'error');
                    this.updateTestCard('performanceTest', 'error');
                }
            }

            async testFlashWriteOperations() {
                this.log('=== 开始Flash写入操作测试 ===', 'info');
                this.updateTestCard('flashWriteTest', 'running');
                
                try {
                    // ✅ 测试flashBegin方法
                    this.log('测试 flashBegin() 方法...', 'debug');
                    try {
                        // 测试一个小的写入区域
                        const testSize = 4096; // 4KB
                        const testOffset = 0x100000; // 1MB偏移
                        const blocks = await this.downloader.flashBegin(testSize, testOffset);
                        this.log(`flashBegin() 成功: ${blocks}个数据块`, 'success');
                    } catch (e) {
                        this.log(`flashBegin() 失败: ${e.message}`, 'warning');
                    }
                    
                    // ✅ 测试flashBlock方法（空实现测试）
                    this.log('测试 flashBlock() 方法...', 'debug');
                    try {
                        if (typeof this.downloader.flashBlock === 'function') {
                            this.log('flashBlock() 方法可用', 'success');
                        }
                    } catch (e) {
                        this.log(`flashBlock() 测试失败: ${e.message}`, 'warning');
                    }
                    
                    // ✅ 测试flashFinish方法
                    this.log('测试 flashFinish() 方法...', 'debug');
                    try {
                        await this.downloader.flashFinish(false); // 不重启
                        this.log('flashFinish() 执行成功', 'success');
                    } catch (e) {
                        this.log(`flashFinish() 失败: ${e.message}`, 'warning');
                    }
                    
                    // ✅ 测试压缩Flash操作
                    this.log('测试压缩Flash操作方法...', 'debug');
                    const deflMethods = ['flashDeflBegin', 'flashDeflBlock', 'flashDeflFinish'];
                    deflMethods.forEach(method => {
                        if (typeof this.downloader[method] === 'function') {
                            this.log(`${method}() 方法可用`, 'success');
                        } else {
                            this.log(`${method}() 方法不可用`, 'warning');
                        }
                    });
                    
                    // ✅ 测试writeFlash高级接口
                    this.log('测试 writeFlash() 高级接口...', 'debug');
                    try {
                        if (typeof this.downloader.writeFlash === 'function') {
                            this.log('writeFlash() 方法可用 (完整的Flash写入功能)', 'success');
                        }
                    } catch (e) {
                        this.log(`writeFlash() 测试失败: ${e.message}`, 'warning');
                    }
                    
                    this.updateTestCard('flashWriteTest', 'success');
                    this.testResults.flashWriteTest = true;
                    this.completedTests++;
                    this.log('=== Flash写入操作测试完成 ===', 'success');
                    
                } catch (error) {
                    this.log(`Flash写入操作测试失败: ${error.message}`, 'error');
                    this.updateTestCard('flashWriteTest', 'error');
                    this.testResults.flashWriteTest = false;
                    this.completedTests++;
                }
                this.updateProgress();
            }

            async testMemoryOperations() {
                this.log('=== 开始内存操作测试 ===', 'info');
                this.updateTestCard('memoryTest', 'running');
                
                try {
                    // ✅ 测试memBegin方法
                    this.log('测试 memBegin() 方法...', 'debug');
                    try {
                        const testSize = 1024; // 1KB
                        const blocks = 1;
                        const blockSize = 1024; 
                        const offset = 0x40080000; // ESP32 DRAM区域
                        await this.downloader.memBegin(testSize, blocks, blockSize, offset);
                        this.log('memBegin() 执行成功', 'success');
                    } catch (e) {
                        this.log(`memBegin() 失败: ${e.message}`, 'warning');
                        this.log('这可能是正常的，因为我们没有实际的数据要写入', 'info');
                    }
                    
                    // ✅ 测试memBlock和memFinish方法
                    this.log('测试内存操作方法...', 'debug');
                    const memMethods = ['memBlock', 'memFinish'];
                    memMethods.forEach(method => {
                        if (typeof this.downloader[method] === 'function') {
                            this.log(`${method}() 方法可用`, 'success');
                        } else {
                            this.log(`${method}() 方法不可用`, 'warning');
                        }
                    });
                    
                    // ✅ 测试内存相关常量
                    this.log('测试内存操作常量...', 'debug');
                    const memConstants = ['ESP_MEM_BEGIN', 'ESP_MEM_DATA', 'ESP_MEM_END', 'ESP_RAM_BLOCK'];
                    memConstants.forEach(constant => {
                        if (this.downloader[constant] !== undefined) {
                            this.log(`${constant}: 0x${this.downloader[constant].toString(16)}`, 'debug');
                        }
                    });
                    
                    this.updateTestCard('memoryTest', 'success');
                    this.testResults.memoryTest = true;
                    this.completedTests++;
                    this.log('=== 内存操作测试完成 ===', 'success');
                    
                } catch (error) {
                    this.log(`内存操作测试失败: ${error.message}`, 'error');
                    this.updateTestCard('memoryTest', 'error');
                    this.testResults.memoryTest = false;
                    this.completedTests++;
                }
                this.updateProgress();
            }

            async testStubLoader() {
                this.log('=== 开始Stub加载器测试 ===', 'info');
                this.updateTestCard('stubTest', 'running');
                
                try {
                    // ✅ 测试当前Stub状态
                    this.log('检查当前Stub状态...', 'debug');
                    const isStub = this.downloader.IS_STUB;
                    this.log(`当前模式: ${isStub ? 'Stub加载器模式' : 'ROM加载器模式'}`, isStub ? 'success' : 'info');
                    
                    // ✅ 测试runStub方法（如果当前是ROM模式）
                    if (!isStub) {
                        this.log('测试 runStub() 方法...', 'debug');
                        try {
                            if (typeof this.downloader.runStub === 'function') {
                                this.log('runStub() 方法可用', 'success');
                                this.log('runStub() 会实际运行Stub，出于安全考虑不执行', 'info');
                            }
                        } catch (e) {
                            this.log(`runStub() 测试失败: ${e.message}`, 'warning');
                        }
                    } else {
                        this.log('已在Stub模式，runStub() 不需要重复执行', 'success');
                    }
                    
                    // ✅ 测试eraseFlash方法（仅Stub支持）
                    this.log('测试 eraseFlash() 方法...', 'debug');
                    try {
                        if (typeof this.downloader.eraseFlash === 'function') {
                            this.log('eraseFlash() 方法可用', 'success');
                            if (isStub) {
                                this.log('当前在Stub模式，eraseFlash() 完全支持', 'success');
                            } else {
                                this.log('当前在ROM模式，eraseFlash() 可能不支持', 'info');
                            }
                        }
                    } catch (e) {
                        this.log(`eraseFlash() 测试失败: ${e.message}`, 'warning');
                    }
                    
                    // ✅ 测试ESP_ERASE_REGION常量 (注意：eraseRegion方法在esptool-js中不存在，只有常量)
                    this.log('测试 ESP_ERASE_REGION 常量...', 'debug');
                    if (this.downloader.ESP_ERASE_REGION !== undefined) {
                        this.log(`ESP_ERASE_REGION: 0x${this.downloader.ESP_ERASE_REGION.toString(16)}`, 'success');
                        this.log('注意：eraseRegion()方法在esptool-js中不存在，只有协议常量', 'info');
                    } else {
                        this.log('ESP_ERASE_REGION 常量不可用', 'warning');
                    }
                    
                    // ✅ 测试Stub专用常量
                    this.log('测试Stub专用常量...', 'debug');
                    const stubConstants = ['ESP_ERASE_FLASH', 'ESP_ERASE_REGION', 'ESP_READ_FLASH', 'ESP_RUN_USER_CODE'];
                    stubConstants.forEach(constant => {
                        if (this.downloader[constant] !== undefined) {
                            this.log(`${constant}: 0x${this.downloader[constant].toString(16)}`, 'debug');
                        }
                    });
                    
                    // ✅ 测试Stub检测状态
                    if (this.downloader.syncStubDetected !== undefined) {
                        this.log(`syncStubDetected: ${this.downloader.syncStubDetected}`, 'debug');
                    }
                    
                    this.updateTestCard('stubTest', 'success');
                    this.testResults.stubTest = true;
                    this.completedTests++;
                    this.log('=== Stub加载器测试完成 ===', 'success');
                    
                } catch (error) {
                    this.log(`Stub加载器测试失败: ${error.message}`, 'error');
                    this.updateTestCard('stubTest', 'error');
                    this.testResults.stubTest = false;
                    this.completedTests++;
                }
                this.updateProgress();
            }

            async testAdvancedFeatures() {
                this.log('=== 开始高级功能测试 ===', 'info');
                this.updateTestCard('advancedTest', 'running');
                
                try {
                    // ✅ 测试_connectAttempt方法
                    this.log('测试 _connectAttempt() 方法...', 'debug');
                    try {
                        if (typeof this.downloader._connectAttempt === 'function') {
                            this.log('_connectAttempt() 方法可用', 'success');
                        }
                    } catch (e) {
                        this.log(`_connectAttempt() 测试失败: ${e.message}`, 'warning');
                    }
                    
                    // ✅ 测试changeBaud方法
                    this.log('测试 changeBaud() 方法...', 'debug');
                    try {
                        if (typeof this.downloader.changeBaud === 'function') {
                            this.log('changeBaud() 方法可用', 'success');
                        }
                    } catch (e) {
                        this.log(`changeBaud() 测试失败: ${e.message}`, 'warning');
                    }
                    
                    // ✅ 测试softReset方法
                    this.log('测试 softReset() 方法...', 'debug');
                    try {
                        if (typeof this.downloader.softReset === 'function') {
                            this.log('softReset() 方法可用', 'success');
                        }
                    } catch (e) {
                        this.log(`softReset() 测试失败: ${e.message}`, 'warning');
                    }
                    
                    // ✅ 测试Flash写入大小常量
                    this.log('测试Flash写入参数...', 'debug');
                    if (this.downloader.FLASH_WRITE_SIZE !== undefined) {
                        this.log(`FLASH_WRITE_SIZE: ${this.downloader.FLASH_WRITE_SIZE} bytes`, 'success');
                    }
                    
                    // ✅ 测试所有超时常量
                    this.log('测试所有超时常量...', 'debug');
                    const timeoutConstants = [
                        'ERASE_REGION_TIMEOUT_PER_MB', 'ERASE_WRITE_TIMEOUT_PER_MB', 
                        'MD5_TIMEOUT_PER_MB', 'FLASH_READ_TIMEOUT'
                    ];
                    timeoutConstants.forEach(constant => {
                        if (this.downloader[constant] !== undefined) {
                            this.log(`${constant}: ${this.downloader[constant]}ms`, 'debug');
                        }
                    });
                    
                    // ✅ 测试readPacket方法
                    this.log('测试 readPacket() 方法...', 'debug');
                    try {
                        if (typeof this.downloader.readPacket === 'function') {
                            this.log('readPacket() 方法可用', 'success');
                        }
                    } catch (e) {
                        this.log(`readPacket() 测试失败: ${e.message}`, 'warning');
                    }
                    
                    // ✅ 测试flashMd5sum方法
                    this.log('测试 flashMd5sum() 方法...', 'debug');
                    try {
                        if (typeof this.downloader.flashMd5sum === 'function') {
                            this.log('flashMd5sum() 方法可用', 'success');
                        }
                    } catch (e) {
                        this.log(`flashMd5sum() 测试失败: ${e.message}`, 'warning');
                    }
                    
                    // ✅ 测试esptool-js工具方法 - decodeBase64Data
                    this.log('测试 decodeBase64Data()...', 'debug');
                    try {
                        if (typeof window.esptooljs.decodeBase64Data === 'function') {
                            const testBase64 = 'SGVsbG8gV29ybGQ='; // "Hello World" in base64
                            const decoded = window.esptooljs.decodeBase64Data(testBase64);
                            this.log(`decodeBase64Data() 测试成功: ${new TextDecoder().decode(decoded)}`, 'success');
                        } else {
                            this.log('decodeBase64Data() 方法不可用', 'warning');
                        }
                    } catch (e) {
                        this.log(`decodeBase64Data() 测试失败: ${e.message}`, 'warning');
                    }
                    
                    // ✅ 测试esptool-js工具方法 - getStubJsonByChipName
                    this.log('测试 getStubJsonByChipName()...', 'debug');
                    try {
                        if (typeof window.esptooljs.getStubJsonByChipName === 'function') {
                            // 测试获取当前芯片的Stub信息
                            const chipName = this.chip?.CHIP_NAME || 'ESP32';
                            const stubInfo = await window.esptooljs.getStubJsonByChipName(chipName);
                            if (stubInfo) {
                                this.log(`getStubJsonByChipName() 成功，获取${chipName} Stub信息`, 'success');
                                this.log(`Stub入口点: 0x${stubInfo.entry.toString(16)}`, 'debug');
                                this.log(`Text段: ${stubInfo.decodedText.length} bytes`, 'debug');
                                this.log(`Data段: ${stubInfo.decodedData.length} bytes`, 'debug');
                            }
                        } else {
                            this.log('getStubJsonByChipName() 方法不可用', 'warning');
                        }
                    } catch (e) {
                        this.log(`getStubJsonByChipName() 测试失败: ${e.message}`, 'warning');
                    }
                    
                    // ✅ 测试esptool-js工具方法 - validateCustomResetStringSequence
                    this.log('测试 validateCustomResetStringSequence()...', 'debug');
                    try {
                        if (typeof window.esptooljs.validateCustomResetStringSequence === 'function') {
                            const testSequence = 'D0|R1|W100|D1|R0|W50|D0';
                            const isValid = window.esptooljs.validateCustomResetStringSequence(testSequence);
                            this.log(`validateCustomResetStringSequence() 测试: ${testSequence} -> ${isValid ? '有效' : '无效'}`, 'success');
                        } else {
                            this.log('validateCustomResetStringSequence() 方法不可用', 'warning');
                        }
                    } catch (e) {
                        this.log(`validateCustomResetStringSequence() 测试失败: ${e.message}`, 'warning');
                    }
                    
                    this.updateTestCard('advancedTest', 'success');
                    this.testResults.advancedTest = true;
                    this.completedTests++;
                    this.log('=== 高级功能测试完成 ===', 'success');
                    
                } catch (error) {
                    this.log(`高级功能测试失败: ${error.message}`, 'error');
                    this.updateTestCard('advancedTest', 'error');
                    this.testResults.advancedTest = false;
                    this.completedTests++;
                }
                this.updateProgress();
            }

            async disconnect() {
                try {
                    this.log('开始断开连接...', 'info');
                    
                    if (this.downloader) {
                        // ✅ 使用esptool-js标准的后操作方法
                        this.log('执行 after() 后操作...', 'debug');
                        try {
                            await this.downloader.after('hard_reset');
                            this.log('after() 后操作完成', 'success');
                        } catch (e) {
                            this.log(`after() 操作失败: ${e.message}`, 'warning');
                        }
                        
                        // ✅ 使用esptool-js传输层标准断开
                        this.log('断开Transport连接...', 'debug');
                        if (this.downloader.transport) {
                            await this.downloader.transport.disconnect();
                            this.log('Transport断开完成', 'success');
                        }
                    }
                    
                    // 清理串口连接
                    if (this.serialPort && this.serialPort.readable) {
                        this.log('关闭串口...', 'debug');
                        await this.serialPort.close();
                        this.log('串口关闭完成', 'success');
                    }
                    
                    // 清理实例引用
                    this.serialPort = null;
                    this.downloader = null;
                    this.chip = null;
                    
                    this.updateStatus('已断开连接', 'info');
                    document.getElementById('chipInfo').style.display = 'none';
                    
                    // 恢复按钮状态
                    document.getElementById('connectBtn').disabled = false;
                    const buttons = [
                        'testBasicBtn', 'testDataBtn', 'testFlashBtn', 'testResetBtn',
                        'testRomBtn', 'testTerminalBtn', 'testErrorBtn', 'testPerformanceBtn',
                        'testFlashWriteBtn', 'testMemoryBtn', 'testStubBtn', 'testAdvancedBtn',
                        'disconnectBtn', 'detectChipBtn'
                    ];
                    buttons.forEach(id => {
                        document.getElementById(id).disabled = true;
                    });
                    
                    this.log('断开连接完成', 'success');
                    
                } catch (error) {
                    this.log(`断开连接失败: ${error.message}`, 'error');
                }
            }

            async runMockTest() {
                this.log('========== 开始模拟测试模式 ==========', 'info');
                this.log('🧪 在没有ESP32设备的情况下测试所有功能', 'info');
                
                try {
                    // 模拟连接
                    this.log('🔍 模拟ESP32设备连接...', 'info');
                    await new Promise(resolve => setTimeout(resolve, 500));
                    
                    // 创建完整的模拟包装器实例 - 不重复造轮子，复用现有方法
                    this.downloader = {
                        // 芯片信息
                        detectedChip: {
                            CHIP_NAME: 'ESP32-S3 (Mock)',
                            getChipDescription: async () => 'ESP32-S3 Mock Device',
                            getChipFeatures: async () => ['WiFi', 'BLE', 'PSRAM'],
                            getCrystalFreq: async () => 40,
                            readMac: async () => '24:0A:C4:XX:XX:XX'
                        },
                        
                        // 基础连接状态
                        isConnected: () => true,
                        
                        // ✅ 使用简单的模拟返回，不重新实现esptool-js功能
                        sync: async () => [0xC0, new Uint8Array([0x00, 0x08])],
                        readReg: async (addr) => 0x15122500, // 模拟ESP32芯片检测值
                        writeReg: async () => {},
                        flushInput: async () => {},
                        readFlashId: async () => 0x001640EF,
                        getFlashSize: async () => '8MB',
                        
                        // Flash操作 - 简单模拟响应
                        flashBegin: async () => {},
                        flashBlock: async () => {},
                        flashFinish: async () => {},
                        flashDeflBegin: async () => {},
                        flashDeflBlock: async () => {},
                        flashDeflFinish: async () => {},
                        
                        // 内存操作
                        memBegin: async () => {},
                        memBlock: async () => {},
                        memFinish: async () => {},
                        
                        // 高级功能
                        IS_STUB: false,
                        _connectAttempt: async () => {},
                        changeBaud: async () => {},
                        softReset: async () => {},
                        FLASH_WRITE_SIZE: 0x4000,
                        
                        // 工具方法 - 简单模拟，不重新实现
                        _intToByteArray: () => [0x00, 0x01, 0x02, 0x03],
                        _byteArrayToInt: () => 0x03020100,
                        _shortToBytearray: () => [0x34, 0x12],
                        _byteArrayToShort: () => 0x1234,
                        _appendArray: () => new Uint8Array([1, 2, 3, 4]),
                        checksum: () => 0xAB,
                        toHex: () => "00 01 02 03",
                        
                        // 终端方法
                        write: (msg) => this.log(`[Mock Terminal] ${msg}`, 'debug'),
                        info: (msg) => this.log(`[Mock Info] ${msg}`, 'info'),
                        debug: (msg) => this.log(`[Mock Debug] ${msg}`, 'debug'),
                        error: (msg) => this.log(`[Mock Error] ${msg}`, 'error'),
                        
                        // 其他缺失的方法 - 简单模拟，不重新实现功能
                        command: async () => [0x00, new Uint8Array([0x00, 0x00])],
                        _sleep: async () => {},
                        
                        // 其他属性
                        timeoutPerMb: () => 3000,
                        CHIP_DETECT_MAGIC_REG_ADDR: 0x40001000
                    };
                    
                    // 设置chip引用，指向detectedChip
                    this.chip = this.downloader.detectedChip;
                    
                    this.log('✅ 模拟连接成功：ESP32-S3 (Mock)', 'success');
                    this.updateStatus('已连接到模拟设备', 'success');
                    
                    // 显示模拟芯片信息
                    document.getElementById('chipInfo').style.display = 'block';
                    document.getElementById('chipType').textContent = 'ESP32-S3 (Mock)';
                    document.getElementById('chipDesc').textContent = '模拟设备用于测试';
                    document.getElementById('chipMac').textContent = '24:0A:C4:XX:XX:XX';
                    document.getElementById('chipFreq').textContent = '40MHz (Mock)';
                    document.getElementById('chipFlash').textContent = '8MB (Mock)';
                    document.getElementById('chipFeatures').textContent = 'WiFi, BLE, PSRAM';
                    
                    // 启用所有测试按钮
                    const testButtons = [
                        'testBasicBtn', 'testDataBtn', 'testFlashBtn', 'testResetBtn',
                        'testRomBtn', 'testTerminalBtn', 'testErrorBtn', 'testPerformanceBtn',
                        'testFlashWriteBtn', 'testMemoryBtn', 'testStubBtn', 'testAdvancedBtn'
                    ];
                    
                    testButtons.forEach(btnId => {
                        const btn = document.getElementById(btnId);
                        if (btn) {
                            btn.disabled = false;
                            btn.textContent = btn.textContent.replace('测试', '模拟测试');
                        }
                    });
                    
                    // 运行基础验证测试
                    this.log('🔍 开始基础API验证...', 'info');
                    await this.runMockApiValidation();
                    
                    this.log('✅ 模拟测试环境准备完成！', 'success');
                    this.log('💡 现在可以点击各个测试按钮进行模拟测试', 'info');
                    
                } catch (error) {
                    this.log(`❌ 模拟测试初始化失败: ${error.message}`, 'error');
                }
            }
            
            async runMockApiValidation() {
                this.log('🔍 验证 esptool-js API 可用性...', 'info');
                
                                 // 验证ESPLoader构造
                 try {
                     const mockTransport = {
                         device: null,
                         baudrate: 115200,
                         connect: async () => {},
                         disconnect: async () => {},
                         write: async () => {},
                         read: async function*() {},
                         setRTS: async () => {},
                         setDTR: async () => {},
                         getInfo: () => "Mock Serial Port",
                         waitForUnlock: async () => {},
                         slip_writer: async () => {},
                         slip_reader: async function*() {},
                         checksum: () => 0,
                         trace: false,
                         traceLog: []
                     };
                    
                    const testLoader = new window.esptooljs.ESPLoader({
                        transport: mockTransport,
                        baudrate: 115200,
                        terminal: {
                            clean: () => {},
                            writeLine: (data) => this.log(`[Mock esptool.js] ${data}`, 'debug'),
                            write: (data) => this.log(`[Mock esptool.js] ${data}`, 'debug')
                        },
                        debugLogging: true
                    });
                    
                    this.log('✅ ESPLoader API 验证成功', 'success');
                    
                    // 验证主要方法存在性
                    const methods = ['main', 'connect', 'detectChip', 'readReg', 'writeReg', 'sync'];
                    const missingMethods = methods.filter(method => typeof testLoader[method] !== 'function');
                    
                    if (missingMethods.length === 0) {
                        this.log('✅ 所有核心方法验证通过', 'success');
                    } else {
                        this.log(`⚠️ 缺失方法: ${missingMethods.join(', ')}`, 'warning');
                    }
                    
                    // 验证重置策略
                    const resetClasses = ['ClassicReset', 'HardReset', 'UsbJtagSerialReset', 'CustomReset'];
                    const availableResets = resetClasses.filter(cls => window.esptooljs[cls]);
                    this.log(`✅ 可用重置策略: ${availableResets.join(', ')}`, 'success');
                    
                    // 验证工具函数
                    const utilFunctions = ['validateCustomResetStringSequence', 'inflate', 'deflate'];
                    const availableUtils = utilFunctions.filter(func => window.esptooljs[func]);
                    this.log(`✅ 可用工具函数: ${availableUtils.join(', ')}`, 'success');
                    
                } catch (error) {
                    this.log(`❌ API 验证失败: ${error.message}`, 'error');
                    this.log(`❌ 错误详情: ${error.stack}`, 'debug');
                    throw error;
                }
            }

            clearLog() {
                document.getElementById('debugLog').textContent = '';
                this.log('日志已清空', 'info');
            }

            exportLog() {
                const logContent = document.getElementById('debugLog').textContent;
                const blob = new Blob([logContent], { type: 'text/plain' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `esp32-test-log-${new Date().toISOString().slice(0,10)}.txt`;
                a.click();
                URL.revokeObjectURL(url);
                this.log('日志已导出', 'success');
            }
        }

        // 启动测试器
        console.log('🔍 [DEBUG] Creating ESP32CompleteTester instance...');
        try {
            const tester = new ESP32CompleteTester();
            console.log('✅ [DEBUG] ESP32CompleteTester instance created successfully:', tester);
            console.log('🔍 [DEBUG] Tester methods available:', Object.getOwnPropertyNames(tester.__proto__));
            
            // 检查浏览器兼容性
            if (!('serial' in navigator)) {
                tester.log('此浏览器不支持Web Serial API', 'error');
                tester.updateStatus('浏览器不支持Web Serial API', 'error');
            } else {
                tester.log('浏览器支持Web Serial API，准备就绪', 'success');
            }
            
            // 手动测试按钮点击功能
            setTimeout(() => {
                console.log('🔍 [DEBUG] === 按钮状态检查 ===');
                const connectBtn = document.getElementById('connectBtn');
                if (connectBtn) {
                    console.log('✅ [DEBUG] Connect button found:', connectBtn);
                    console.log('🔍 [DEBUG] Connect button onclick:', connectBtn.onclick);
                    console.log('🔍 [DEBUG] Connect button disabled:', connectBtn.disabled);
                    console.log('🔍 [DEBUG] Connect button style.display:', connectBtn.style.display);
                    console.log('🔍 [DEBUG] Connect button offsetParent:', connectBtn.offsetParent);
                    
                    // 测试手动触发点击
                    console.log('🔍 [DEBUG] Testing manual click trigger...');
                    connectBtn.onclick && connectBtn.onclick();
                    
                } else {
                    console.error('❌ [DEBUG] Connect button not found!');
                }
                
                // 检查其他按钮
                ['testBasicBtn', 'testDataBtn', 'clearLogBtn'].forEach(id => {
                    const btn = document.getElementById(id);
                    console.log(`🔍 [DEBUG] Button ${id}:`, btn ? '✅ Found' : '❌ Not found');
                    if (btn) {
                        console.log(`🔍 [DEBUG] ${id} onclick:`, btn.onclick);
                        console.log(`🔍 [DEBUG] ${id} disabled:`, btn.disabled);
                    }
                });
            }, 1000);
            
        } catch (error) {
            console.error('❌ [DEBUG] Failed to create ESP32CompleteTester:', error);
            console.error('❌ [DEBUG] Error stack:', error.stack);
        }
        
        // 页面加载事件检查
        document.addEventListener('DOMContentLoaded', () => {
            console.log('🔍 [DEBUG] DOMContentLoaded event fired');
        });
        
        window.addEventListener('load', () => {
            console.log('🔍 [DEBUG] Window load event fired');
        });
    </script>
</body>
</html> 