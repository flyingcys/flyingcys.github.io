<!DOCTYPE html>
<html>
<head>
    <title>å¿«é€Ÿè°ƒè¯•æµ‹è¯•</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; background: #f0f0f0; }
        .container { max-width: 800px; margin: 0 auto; background: white; padding: 20px; border-radius: 8px; }
        .btn { padding: 10px 20px; margin: 5px; border: none; border-radius: 4px; cursor: pointer; }
        .btn.primary { background: #007bff; color: white; }
        .btn.success { background: #28a745; color: white; }
        .log { background: #f8f9fa; border: 1px solid #dee2e6; padding: 15px; margin: 10px 0; height: 400px; overflow-y: auto; font-family: monospace; white-space: pre-wrap; }
        .status { padding: 10px; margin: 10px 0; border-radius: 4px; }
        .status.success { background: #d4edda; color: #155724; border: 1px solid #c3e6cb; }
        .status.error { background: #f8d7da; color: #721c24; border: 1px solid #f5c6cb; }
        .status.info { background: #d1ecf1; color: #0c5460; border: 1px solid #bee5eb; }
    </style>
</head>
<body>
    <div class="container">
        <h1>ğŸ”§ å¿«é€Ÿè°ƒè¯•æµ‹è¯•</h1>
        <p>å¿«é€Ÿæ£€æµ‹esptool-js APIæ˜¯å¦æ­£ç¡®åŠ è½½å’Œå¯ç”¨</p>
        
        <button id="quickTestBtn" class="btn primary">ğŸš€ è¿è¡Œå¿«é€Ÿæµ‹è¯•</button>
        <button id="mockConnectBtn" class="btn success">ğŸ§ª æ¨¡æ‹Ÿè¿æ¥æµ‹è¯•</button>
        <button id="transportTestBtn" class="btn success">ğŸ”§ Transportæ¥å£æµ‹è¯•</button>
        <button id="clearBtn" class="btn">ğŸ—‘ï¸ æ¸…ç©ºæ—¥å¿—</button>
        
        <div id="status" class="status info">å‡†å¤‡å°±ç»ª</div>
        <div id="log" class="log">ç­‰å¾…æµ‹è¯•å¼€å§‹...</div>
    </div>

    <!-- åŠ è½½esptool-js -->
    <script src="third_party/esptool-js-umd.bundle.js"></script>
    <script src="downloaders/base-downloader.js"></script>
    <script src="downloaders/esp32-esptool-js-wrapper.js"></script>

    <script>
        function log(message, type = 'info') {
            const timestamp = new Date().toLocaleTimeString();
            const logElement = document.getElementById('log');
            const typeMap = {
                'error': 'âŒ',
                'success': 'âœ…', 
                'debug': 'ğŸ”',
                'info': 'â„¹ï¸',
                'warning': 'âš ï¸'
            };
            const prefix = typeMap[type] || 'â„¹ï¸';
            logElement.textContent += `[${timestamp}] ${prefix} ${message}\n`;
            logElement.scrollTop = logElement.scrollHeight;
        }

        function updateStatus(message, type = 'info') {
            const statusElement = document.getElementById('status');
            statusElement.textContent = message;
            statusElement.className = `status ${type}`;
        }

        async function runQuickTest() {
            log('========== å¼€å§‹å¿«é€Ÿæµ‹è¯• ==========');
            updateStatus('æ­£åœ¨è¿è¡Œå¿«é€Ÿæµ‹è¯•...', 'info');
            
            try {
                // 1. æ£€æŸ¥åŸºç¡€ç¯å¢ƒ
                log('1. æ£€æŸ¥æµè§ˆå™¨æ”¯æŒ...');
                log(`Web Serial API: ${!!navigator.serial ? 'âœ… æ”¯æŒ' : 'âŒ ä¸æ”¯æŒ'}`);
                log(`esptool-jså…¨å±€å¯¹è±¡: ${!!window.esptooljs ? 'âœ… å­˜åœ¨' : 'âŒ ä¸å­˜åœ¨'}`);
                
                if (!window.esptooljs) {
                    throw new Error('esptool-js æœªæ­£ç¡®åŠ è½½');
                }
                
                // 2. æ£€æŸ¥æ ¸å¿ƒç±»
                log('2. æ£€æŸ¥æ ¸å¿ƒç±»...');
                const coreClasses = ['ESPLoader', 'Transport'];
                coreClasses.forEach(className => {
                    const exists = !!window.esptooljs[className];
                    const isConstructor = typeof window.esptooljs[className] === 'function';
                    log(`${className}: ${exists ? 'âœ…' : 'âŒ'} å­˜åœ¨, ${isConstructor ? 'âœ…' : 'âŒ'} æ„é€ å™¨`);
                });
                
                // 3. æµ‹è¯•ESPLoaderæ„é€ 
                log('3. æµ‹è¯•ESPLoaderæ„é€ ...');
                                 const mockTransport = {
                     device: null,
                     baudrate: 115200,
                     connect: async () => {},
                     disconnect: async () => {},
                     write: async () => {},
                     read: async function*() {},
                     setRTS: async () => {},
                     setDTR: async () => {},
                     getInfo: () => "Mock Serial Port",
                     waitForUnlock: async () => {},
                     slip_writer: async () => {},
                     slip_reader: async function*() {},
                     checksum: () => 0,
                     trace: false,
                     traceLog: []
                 };
                
                const testLoader = new window.esptooljs.ESPLoader({
                    transport: mockTransport,
                    baudrate: 115200,
                    terminal: {
                        clean: () => {},
                        writeLine: (data) => log(`[ESPLoader] ${data}`, 'debug'),
                        write: (data) => log(`[ESPLoader] ${data}`, 'debug')
                    },
                    debugLogging: true
                });
                
                log('âœ… ESPLoader æ„é€ æˆåŠŸ!');
                log(`ESPLoader æ–¹æ³•æ•°é‡: ${Object.getOwnPropertyNames(Object.getPrototypeOf(testLoader)).length}`);
                
                // 4. æ£€æŸ¥åŒ…è£…å™¨
                log('4. æ£€æŸ¥åŒ…è£…å™¨...');
                log(`ESP32EsptoolJSWrapper: ${!!window.ESP32EsptoolJSWrapper ? 'âœ… å­˜åœ¨' : 'âŒ ä¸å­˜åœ¨'}`);
                log(`BaseDownloader: ${!!window.BaseDownloader ? 'âœ… å­˜åœ¨' : 'âŒ ä¸å­˜åœ¨'}`);
                
                updateStatus('å¿«é€Ÿæµ‹è¯•é€šè¿‡ï¼', 'success');
                log('========== å¿«é€Ÿæµ‹è¯•å®Œæˆ ==========');
                
            } catch (error) {
                log(`âŒ å¿«é€Ÿæµ‹è¯•å¤±è´¥: ${error.message}`, 'error');
                log(`é”™è¯¯å †æ ˆ: ${error.stack}`, 'debug');
                updateStatus('å¿«é€Ÿæµ‹è¯•å¤±è´¥', 'error');
            }
        }
        
        async function runMockConnectTest() {
            log('========== å¼€å§‹æ¨¡æ‹Ÿè¿æ¥æµ‹è¯• ==========');
            updateStatus('æ­£åœ¨æµ‹è¯•æ¨¡æ‹Ÿè¿æ¥...', 'info');
            
            try {
                // åˆ›å»ºæ¨¡æ‹Ÿä¸²å£
                const mockPort = {
                    open: async () => {},
                    close: async () => {},
                    readable: { getReader: () => ({ read: async () => ({ done: true }) }) },
                    writable: { getWriter: () => ({ write: async () => {}, close: async () => {} }) }
                };
                
                log('åˆ›å»º ESP32EsptoolJSWrapper å®ä¾‹...');
                const wrapper = new window.ESP32EsptoolJSWrapper(mockPort, {
                    log: (msg) => log(`[Wrapper] ${msg}`, 'debug'),
                    debug: (msg) => log(`[Wrapper] ${msg}`, 'debug'),
                    error: (msg) => log(`[Wrapper] ${msg}`, 'error')
                });
                
                log('âœ… åŒ…è£…å™¨å®ä¾‹åˆ›å»ºæˆåŠŸ');
                
                log('æµ‹è¯•åˆå§‹åŒ–...');
                const initResult = await wrapper.initialize();
                log(`åˆå§‹åŒ–ç»“æœ: ${initResult ? 'âœ… æˆåŠŸ' : 'âŒ å¤±è´¥'}`);
                
                if (initResult) {
                    log('âœ… æ¨¡æ‹Ÿè¿æ¥æµ‹è¯•é€šè¿‡ï¼');
                    updateStatus('æ¨¡æ‹Ÿè¿æ¥æµ‹è¯•é€šè¿‡ï¼', 'success');
                } else {
                    throw new Error('åˆå§‹åŒ–å¤±è´¥');
                }
                
                log('========== æ¨¡æ‹Ÿè¿æ¥æµ‹è¯•å®Œæˆ ==========');
                
            } catch (error) {
                log(`âŒ æ¨¡æ‹Ÿè¿æ¥æµ‹è¯•å¤±è´¥: ${error.message}`, 'error');
                log(`é”™è¯¯å †æ ˆ: ${error.stack}`, 'debug');
                updateStatus('æ¨¡æ‹Ÿè¿æ¥æµ‹è¯•å¤±è´¥', 'error');
            }
        }

        async function runTransportTest() {
            console.log('Transportæµ‹è¯•å‡½æ•°è¢«è°ƒç”¨');
            log('========== å¼€å§‹Transportæ¥å£æµ‹è¯• ==========');
            updateStatus('æ­£åœ¨æµ‹è¯•Transportæ¥å£...', 'info');
            
            try {
                // åˆ›å»ºæ¨¡æ‹Ÿä¸²å£
                const mockPort = {
                    open: async () => {},
                    close: async () => {},
                    readable: { getReader: () => ({ read: async () => ({ done: true }) }) },
                    writable: { getWriter: () => ({ write: async () => {}, close: async () => {} }) },
                    setSignals: async () => {},
                    getInfo: () => ({ usbProductId: 0x1234 })
                };
                
                log('åˆ›å»º ESP32EsptoolJSWrapper å®ä¾‹...');
                const wrapper = new window.ESP32EsptoolJSWrapper(mockPort, {
                    log: (msg) => log(`[Wrapper] ${msg}`, 'debug'),
                    debug: (msg) => log(`[Wrapper] ${msg}`, 'debug'),
                    error: (msg) => log(`[Wrapper] ${msg}`, 'error')
                });
                
                log('âœ… åŒ…è£…å™¨å®ä¾‹åˆ›å»ºæˆåŠŸ');
                
                log('æµ‹è¯•Transporté€‚é…å™¨åˆ›å»º...');
                const transport = wrapper.createWebSerialTransport();
                log('âœ… Transporté€‚é…å™¨åˆ›å»ºæˆåŠŸ');
                
                // æµ‹è¯•å…³é”®æ–¹æ³•
                const testMethods = [
                    'connect', 'disconnect', 'write', 'read', 'newRead', 'inWaiting',
                    'rawRead', 'slip_writer', 'slip_reader', 'setRTS', 'setDTR',
                    'reset', 'checksum', 'getInfo', 'getPid', 'trace', 'hexConvert'
                ];
                
                log('æ£€æŸ¥Transportæ–¹æ³•:');
                let missingMethods = [];
                testMethods.forEach(method => {
                    const exists = typeof transport[method] === 'function';
                    log(`  ${method}: ${exists ? 'âœ…' : 'âŒ'} ${typeof transport[method]}`);
                    if (!exists) missingMethods.push(method);
                });
                
                if (missingMethods.length > 0) {
                    throw new Error(`ç¼ºå°‘æ–¹æ³•: ${missingMethods.join(', ')}`);
                }
                
                // æµ‹è¯•å…·ä½“åŠŸèƒ½
                log('æµ‹è¯•inWaiting()...');
                const waiting = transport.inWaiting();
                log(`inWaiting() è¿”å›: ${waiting} (åº”è¯¥æ˜¯æ•°å­—)`);
                
                log('æµ‹è¯•getInfo()...');
                const info = transport.getInfo();
                log(`getInfo() è¿”å›: "${info}"`);
                
                log('æµ‹è¯•getPid()...');
                const pid = transport.getPid();
                log(`getPid() è¿”å›: ${pid}`);
                
                log('æµ‹è¯•checksum()...');
                const testData = new Uint8Array([0x01, 0x02, 0x03]);
                const checksum = transport.checksum(testData);
                log(`checksum([1,2,3]) è¿”å›: 0x${checksum.toString(16)}`);
                
                log('æµ‹è¯•hexConvert()...');
                const hex = transport.hexConvert(testData);
                log(`hexConvert([1,2,3]) è¿”å›: "${hex}"`);
                
                log('âœ… Transportæ¥å£æµ‹è¯•é€šè¿‡ï¼');
                updateStatus('Transportæ¥å£æµ‹è¯•é€šè¿‡ï¼', 'success');
                
                log('========== Transportæ¥å£æµ‹è¯•å®Œæˆ ==========');
                
            } catch (error) {
                log(`âŒ Transportæ¥å£æµ‹è¯•å¤±è´¥: ${error.message}`, 'error');
                log(`é”™è¯¯å †æ ˆ: ${error.stack}`, 'debug');
                updateStatus('Transportæ¥å£æµ‹è¯•å¤±è´¥', 'error');
            }
        }

        // è®¾ç½®æŒ‰é’®äº‹ä»¶
        function setupEventListeners() {
            const quickTestBtn = document.getElementById('quickTestBtn');
            const mockConnectBtn = document.getElementById('mockConnectBtn');
            const transportTestBtn = document.getElementById('transportTestBtn');
            const clearBtn = document.getElementById('clearBtn');
            
            if (quickTestBtn) {
                quickTestBtn.onclick = runQuickTest;
                log('âœ… å¿«é€Ÿæµ‹è¯•æŒ‰é’®äº‹ä»¶å·²ç»‘å®š');
            } else {
                log('âŒ å¿«é€Ÿæµ‹è¯•æŒ‰é’®æœªæ‰¾åˆ°');
            }
            
            if (mockConnectBtn) {
                mockConnectBtn.onclick = runMockConnectTest;
                log('âœ… æ¨¡æ‹Ÿè¿æ¥æµ‹è¯•æŒ‰é’®äº‹ä»¶å·²ç»‘å®š');
            } else {
                log('âŒ æ¨¡æ‹Ÿè¿æ¥æµ‹è¯•æŒ‰é’®æœªæ‰¾åˆ°');
            }
            
            if (transportTestBtn) {
                transportTestBtn.onclick = () => {
                    try {
                        log('ğŸ”˜ Transportæ¥å£æµ‹è¯•æŒ‰é’®è¢«ç‚¹å‡»');
                        runTransportTest().catch(error => {
                            log(`âŒ Transportæµ‹è¯•å¼‚æ­¥é”™è¯¯: ${error.message}`, 'error');
                            console.error('Transport test error:', error);
                        });
                    } catch (error) {
                        log(`âŒ Transportæµ‹è¯•åŒæ­¥é”™è¯¯: ${error.message}`, 'error');
                        console.error('Transport test sync error:', error);
                    }
                };
                log('âœ… Transportæ¥å£æµ‹è¯•æŒ‰é’®äº‹ä»¶å·²ç»‘å®š');
            } else {
                log('âŒ Transportæ¥å£æµ‹è¯•æŒ‰é’®æœªæ‰¾åˆ°');
            }
            
            if (clearBtn) {
                clearBtn.onclick = () => {
            document.getElementById('log').textContent = '';
            log('æ—¥å¿—å·²æ¸…ç©º');
        };
                log('âœ… æ¸…ç©ºæŒ‰é’®äº‹ä»¶å·²ç»‘å®š');
            } else {
                log('âŒ æ¸…ç©ºæŒ‰é’®æœªæ‰¾åˆ°');
            }
        }

        // é¡µé¢åŠ è½½æ—¶è¿è¡ŒåŸºç¡€æ£€æŸ¥
        window.addEventListener('load', () => {
            log('é¡µé¢åŠ è½½å®Œæˆï¼Œå‡†å¤‡å°±ç»ª');
            setupEventListeners();
            log('å¯ä»¥ç‚¹å‡»"è¿è¡Œå¿«é€Ÿæµ‹è¯•"å¼€å§‹æµ‹è¯•');
        });
    </script>
</body>
</html> 