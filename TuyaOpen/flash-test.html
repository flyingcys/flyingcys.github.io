<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ESP32 å›ºä»¶ä¸‹è½½æµ‹è¯•</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; }
        .btn { padding: 10px 20px; margin: 5px; border: none; border-radius: 4px; cursor: pointer; }
        .btn-primary { background: #007bff; color: white; }
        .btn-secondary { background: #6c757d; color: white; }
        .log { background: #f8f9fa; border: 1px solid #dee2e6; padding: 10px; margin: 10px 0; height: 300px; overflow-y: auto; }
        .log-entry { margin: 2px 0; }
        .success { color: green; }
        .error { color: red; }
        .warning { color: orange; }
        .info { color: blue; }
        .debug { color: gray; }
        select { padding: 8px; margin: 5px; }
    </style>
</head>
<body>
    <h1>ESP32 å›ºä»¶ä¸‹è½½æµ‹è¯•</h1>
    
    <div>
        <label>è®¾å¤‡ç±»å‹:</label>
        <select id="deviceSelect">
            <option value="T5AI">T5AI</option>
            <option value="ESP32-Series" selected>ESP32-Series (è‡ªåŠ¨æ£€æµ‹)</option>
            <option value="ESP32">ESP32</option>
            <option value="ESP32C3">ESP32-C3</option>
            <option value="ESP32S3">ESP32-S3</option>
        </select>
    </div>
    
    <div>
        <button id="testConnectBtn" class="btn btn-primary">ğŸ”§ æµ‹è¯•è¿æ¥</button>
        <button id="detectChipBtn" class="btn btn-secondary" disabled>ğŸ” æ£€æµ‹èŠ¯ç‰‡</button>
        <button id="resetDeviceBtn" class="btn btn-secondary" disabled>ğŸ”„ é‡ç½®è®¾å¤‡</button>
        <button id="clearLogBtn" class="btn btn-secondary">ğŸ—‘ï¸ æ¸…ç©ºæ—¥å¿—</button>
    </div>
    
    <div>
        <label>
            <input type="checkbox" id="debugMode" checked> è°ƒè¯•æ¨¡å¼
        </label>
    </div>
    
    <div id="logDisplay" class="log">
        <div class="placeholder">ç­‰å¾…æ“ä½œ...</div>
    </div>

    <!-- å¼•å…¥å¿…è¦çš„è„šæœ¬ -->
    <script src="third_party/esptool-js-umd.bundle.js"></script>
    <script src="downloaders/base-downloader.js"></script>
    <script src="downloaders/esp32/index.js"></script>
    
    <script>
        class SimpleESP32Manager {
            constructor() {
                this.downloader = null;
                this.isConnected = false;
                this.chipInfo = null;
                this.serialPort = null;
                
                this.initEvents();
            }
            
            initEvents() {
                const testBtn = document.getElementById('testConnectBtn');
                const detectBtn = document.getElementById('detectChipBtn');
                const resetBtn = document.getElementById('resetDeviceBtn');
                const clearBtn = document.getElementById('clearLogBtn');
                const deviceSelect = document.getElementById('deviceSelect');
                
                if (testBtn) {
                    testBtn.addEventListener('click', () => this.testConnection());
                }
                
                if (detectBtn) {
                    detectBtn.addEventListener('click', () => this.detectChip());
                }
                
                if (resetBtn) {
                    resetBtn.addEventListener('click', () => this.testReset());
                }
                
                if (clearBtn) {
                    clearBtn.addEventListener('click', () => this.clearLog());
                }
                
                if (deviceSelect) {
                    deviceSelect.addEventListener('change', (e) => {
                        this.log('è®¾å¤‡ç±»å‹å·²åˆ‡æ¢: ' + e.target.value, 'info');
                    });
                }
            }
            
            isESP32Device(deviceType) {
                return ['ESP32-Series', 'ESP32', 'ESP32C3', 'ESP32S3'].includes(deviceType);
            }
            
            async testConnection() {
                try {
                    this.log('=== ESP32è¿æ¥æµ‹è¯•å¼€å§‹ ===', 'info');
                    
                    // æ£€æŸ¥æµè§ˆå™¨æ”¯æŒ
                    if (!('serial' in navigator)) {
                        throw new Error('æµè§ˆå™¨ä¸æ”¯æŒWeb Serial API');
                    }
                    this.log('âœ… æµè§ˆå™¨æ”¯æŒWeb Serial API', 'success');
                    
                    // æ£€æŸ¥ESP32åŒ…è£…å™¨
                    if (typeof ESP32EsptoolJSWrapper === 'undefined') {
                        throw new Error('ESP32EsptoolJSWrapperæœªåŠ è½½');
                    }
                    this.log('âœ… ESP32EsptoolJSWrapperå·²åŠ è½½', 'success');
                    
                    // è¯·æ±‚ä¸²å£
                    this.log('è¯·é€‰æ‹©ESP32è®¾å¤‡ä¸²å£...', 'info');
                    const port = await navigator.serial.requestPort();
                    this.serialPort = port;
                    this.log('âœ… ä¸²å£é€‰æ‹©æˆåŠŸ', 'success');
                    
                    // åˆ›å»ºä¸‹è½½å™¨å®ä¾‹
                    this.downloader = new ESP32EsptoolJSWrapper(port, {
                        log: (msg) => this.log('[Wrapper] ' + msg, 'debug'),
                        error: (msg) => this.log('[Wrapper] ' + msg, 'error'),
                        info: (msg) => this.log('[Wrapper] ' + msg, 'info')
                    });
                    this.log('âœ… ESP32EsptoolJSWrapperå®ä¾‹åˆ›å»ºæˆåŠŸ', 'success');
                    
                    // åˆå§‹åŒ–
                    const initialized = await this.downloader.initialize();
                    if (!initialized) {
                        throw new Error('ESP32åŒ…è£…å™¨åˆå§‹åŒ–å¤±è´¥');
                    }
                    this.log('âœ… ESP32åŒ…è£…å™¨åˆå§‹åŒ–æˆåŠŸ', 'success');
                    
                    // è¿æ¥æµ‹è¯•
                    const connected = await this.downloader.connect();
                    if (connected) {
                        this.isConnected = true;
                        this.chipInfo = this.downloader.getChipInfo();
                        
                        this.log('âœ… ESP32è®¾å¤‡è¿æ¥æˆåŠŸ!', 'success');
                        
                        if (this.chipInfo) {
                            this.log('èŠ¯ç‰‡ä¿¡æ¯: ' + JSON.stringify(this.chipInfo), 'info');
                        }
                        
                        // å¯ç”¨æ£€æµ‹èŠ¯ç‰‡å’Œé‡ç½®æŒ‰é’®
                        const detectBtn = document.getElementById('detectChipBtn');
                        const resetBtn = document.getElementById('resetDeviceBtn');
                        if (detectBtn) detectBtn.disabled = false;
                        if (resetBtn) resetBtn.disabled = false;
                        
                        this.log('=== ESP32è¿æ¥æµ‹è¯•å®Œæˆ ===', 'success');
                        
                    } else {
                        throw new Error('ESP32è®¾å¤‡è¿æ¥å¤±è´¥');
                    }
                    
                } catch (error) {
                    this.log('è¿æ¥æµ‹è¯•å¤±è´¥: ' + error.message, 'error');
                    this.log('ğŸ’¡ æç¤º: è¯·ç¡®ä¿ESP32å·²è¿æ¥å¹¶è¿›å…¥ä¸‹è½½æ¨¡å¼ï¼ˆæŒ‰ä½BOOTæŒ‰é’®é‡å¯ï¼‰', 'info');
                }
            }
            
            async detectChip() {
                try {
                    this.log('=== ESP32èŠ¯ç‰‡æ£€æµ‹å¼€å§‹ ===', 'info');
                    
                    if (!this.isConnected || !this.downloader) {
                        this.log('è¯·å…ˆè¿›è¡Œè¿æ¥æµ‹è¯•', 'warning');
                        return;
                    }
                    
                    // å¤ä½ç­–ç•¥æµ‹è¯•
                    this.log('=== æµ‹è¯•å¤ä½ç­–ç•¥ ===', 'info');
                    
                    try {
                        this.log('ğŸ”„ æµ‹è¯•ClassicResetå¤ä½ç­–ç•¥...', 'debug');
                        const classicReset = this.downloader.createClassicReset();
                        await classicReset.reset();
                        this.log('âœ… ClassicReset å¤ä½å®Œæˆ', 'success');
                        await new Promise(resolve => setTimeout(resolve, 300));
                    } catch (resetError) {
                        this.log('âš ï¸ ClassicReset å¤±è´¥: ' + resetError.message, 'warning');
                    }
                    
                    try {
                        this.log('ğŸ”„ æµ‹è¯•HardResetå¤ä½ç­–ç•¥...', 'debug');
                        const hardReset = this.downloader.createHardReset();
                        await hardReset.reset();
                        this.log('âœ… HardReset å¤ä½å®Œæˆ', 'success');
                        await new Promise(resolve => setTimeout(resolve, 300));
                    } catch (resetError) {
                        this.log('âš ï¸ HardReset å¤±è´¥: ' + resetError.message, 'warning');
                    }
                    
                    // åŒæ­¥æµ‹è¯•
                    this.log('æµ‹è¯•è®¾å¤‡åŒæ­¥...', 'debug');
                    await this.downloader.sync();
                    this.log('âœ… è®¾å¤‡åŒæ­¥æˆåŠŸ', 'success');
                    
                    // è¯»å–èŠ¯ç‰‡ID
                    this.log('è¯»å–èŠ¯ç‰‡ID...', 'debug');
                    const chipId = await this.downloader.getChipId();
                    if (chipId) {
                        this.log('èŠ¯ç‰‡ID: 0x' + chipId.toString(16), 'success');
                    }
                    
                    // å°è¯•è¯»å–Flash ID
                    this.log('å°è¯•è¯»å–Flash ID...', 'debug');
                    try {
                        const flashId = await this.downloader.getFlashId();
                        if (flashId) {
                            this.log('Flash ID: 0x' + flashId.toString(16), 'success');
                        }
                    } catch (e) {
                        this.log('Flash IDè¯»å–å¤±è´¥ï¼ˆROMæ¨¡å¼ä¸‹æ­£å¸¸ï¼‰: ' + e.message, 'warning');
                    }
                    
                    // è·å–è®¾å¤‡çŠ¶æ€
                    const status = this.downloader.getDeviceStatus();
                    this.log('è®¾å¤‡çŠ¶æ€: è¿æ¥=' + status.isConnected + ', loaderå°±ç»ª=' + status.espLoaderReady, 'info');
                    
                    this.log('=== ESP32èŠ¯ç‰‡æ£€æµ‹å®Œæˆ ===', 'success');
                    
                } catch (error) {
                    this.log('èŠ¯ç‰‡æ£€æµ‹å¤±è´¥: ' + error.message, 'error');
                }
            }
            
            log(message, type = 'info') {
                try {
                    const debugMode = document.getElementById('debugMode');
                    const isDebugMode = debugMode ? debugMode.checked : true;
                    
                    if (!isDebugMode && type === 'debug') {
                        return; // éè°ƒè¯•æ¨¡å¼ä¸‹ä¸æ˜¾ç¤ºdebugæ—¥å¿—
                    }
                    
                    const logDisplay = document.getElementById('logDisplay');
                    if (!logDisplay) {
                        console.log('[ESP32]', message);
                        return;
                    }
                    
                    const timestamp = new Date().toLocaleTimeString();
                    
                    const logEntry = document.createElement('div');
                    logEntry.className = 'log-entry ' + type;
                    
                    let icon = 'ğŸ“';
                    switch (type) {
                        case 'success': icon = 'âœ…'; break;
                        case 'error': icon = 'âŒ'; break;
                        case 'warning': icon = 'âš ï¸'; break;
                        case 'debug': icon = 'ğŸ”'; break;
                        case 'info': 
                        default: icon = 'â„¹ï¸'; break;
                    }
                    
                    logEntry.innerHTML = 
                        '<span>[' + timestamp + ']</span> ' +
                        '<span>' + icon + '</span> ' +
                        '<span>' + message + '</span>';
                    
                    // æ¸…é™¤å ä½ç¬¦
                    const placeholder = logDisplay.querySelector('.placeholder');
                    if (placeholder) {
                        logDisplay.innerHTML = '';
                    }
                    
                    logDisplay.appendChild(logEntry);
                    logDisplay.scrollTop = logDisplay.scrollHeight;
                    
                } catch (error) {
                    console.error('log error:', error);
                    console.log('[ESP32]', message);
                }
            }
            
            async testReset() {
                try {
                    this.log('=== ESP32å¤ä½åŠŸèƒ½æµ‹è¯•å¼€å§‹ ===', 'info');
                    
                    if (!this.isConnected || !this.downloader) {
                        this.log('è¯·å…ˆè¿›è¡Œè¿æ¥æµ‹è¯•', 'warning');
                        return;
                    }
                    
                    // æµ‹è¯•åŸºæœ¬DTR/RTSæ§åˆ¶
                    this.log('=== æµ‹è¯•DTR/RTSæ§åˆ¶åŠŸèƒ½ ===', 'info');
                    const transport = this.downloader.transport;
                    
                    if (transport && transport.setDTR && transport.setRTS) {
                        this.log('âœ… DTR/RTSæ–¹æ³•å¯ç”¨', 'success');
                        
                        // æµ‹è¯•DTRæ§åˆ¶
                        this.log('ğŸ”„ æµ‹è¯•DTRæ§åˆ¶...', 'debug');
                        await transport.setDTR(false);
                        this.log('DTRè®¾ç½®ä¸ºLOW', 'debug');
                        await new Promise(resolve => setTimeout(resolve, 100));
                        await transport.setDTR(true);
                        this.log('DTRè®¾ç½®ä¸ºHIGH', 'debug');
                        await new Promise(resolve => setTimeout(resolve, 100));
                        await transport.setDTR(false);
                        this.log('âœ… DTRæ§åˆ¶æµ‹è¯•å®Œæˆ', 'success');
                        
                        // æµ‹è¯•RTSæ§åˆ¶
                        this.log('ğŸ”„ æµ‹è¯•RTSæ§åˆ¶...', 'debug');
                        await transport.setRTS(false);
                        this.log('RTSè®¾ç½®ä¸ºLOW', 'debug');
                        await new Promise(resolve => setTimeout(resolve, 100));
                        await transport.setRTS(true);
                        this.log('RTSè®¾ç½®ä¸ºHIGH', 'debug');
                        await new Promise(resolve => setTimeout(resolve, 100));
                        await transport.setRTS(false);
                        this.log('âœ… RTSæ§åˆ¶æµ‹è¯•å®Œæˆ', 'success');
                        
                    } else {
                        this.log('âŒ DTR/RTSæ–¹æ³•ä¸å¯ç”¨', 'error');
                    }
                    
                    // æµ‹è¯•esptool-jsåŸç”Ÿresetç­–ç•¥
                    this.log('=== æµ‹è¯•esptool-jsåŸç”Ÿå¤ä½ç­–ç•¥ ===', 'info');
                    
                    // ClassicReset (ä¸T5AIç±»ä¼¼çš„å¤ä½åºåˆ—)
                    try {
                        this.log('ğŸ”„ æµ‹è¯•ClassicReset...', 'debug');
                        const classicReset = this.downloader.createClassicReset();
                        this.log('ClassicResetå®ä¾‹åˆ›å»ºæˆåŠŸ', 'debug');
                        await classicReset.reset();
                        this.log('âœ… ClassicResetæ‰§è¡Œå®Œæˆ', 'success');
                    } catch (error) {
                        this.log('âš ï¸ ClassicResetå¤±è´¥: ' + error.message, 'warning');
                    }
                    
                    await new Promise(resolve => setTimeout(resolve, 500));
                    
                    // HardReset 
                    try {
                        this.log('ğŸ”„ æµ‹è¯•HardReset...', 'debug');
                        const hardReset = this.downloader.createHardReset();
                        this.log('HardResetå®ä¾‹åˆ›å»ºæˆåŠŸ', 'debug');
                        await hardReset.reset();
                        this.log('âœ… HardResetæ‰§è¡Œå®Œæˆ', 'success');
                    } catch (error) {
                        this.log('âš ï¸ HardResetå¤±è´¥: ' + error.message, 'warning');
                    }
                    
                    await new Promise(resolve => setTimeout(resolve, 500));
                    
                    // CustomReset - ä½¿ç”¨ç»å…¸åºåˆ— 
                    try {
                        this.log('ğŸ”„ æµ‹è¯•CustomReset (ç»å…¸åºåˆ—)...', 'debug');
                        // ç»å…¸åºåˆ—: "D0|R1|W100|D1|R0|W50|D0" 
                        // D=DTR, R=RTS, W=Wait
                        const customReset = this.downloader.createCustomReset("D0|R1|W100|D1|R0|W50|D0");
                        this.log('CustomResetå®ä¾‹åˆ›å»ºæˆåŠŸ', 'debug');
                        await customReset.reset();
                        this.log('âœ… CustomResetæ‰§è¡Œå®Œæˆ', 'success');
                    } catch (error) {
                        this.log('âš ï¸ CustomResetå¤±è´¥: ' + error.message, 'warning');
                    }
                    
                    this.log('=== ESP32å¤ä½åŠŸèƒ½æµ‹è¯•å®Œæˆ ===', 'success');
                    this.log('ğŸ’¡ æç¤º: DTRå’ŒRTSåŠŸèƒ½å·²éªŒè¯ï¼Œä¸T5AIå’Œesptool-jså…¼å®¹', 'info');
                    
                } catch (error) {
                    this.log('å¤ä½æµ‹è¯•å¤±è´¥: ' + error.message, 'error');
                }
            }
            
            clearLog() {
                const logDisplay = document.getElementById('logDisplay');
                if (logDisplay) {
                    logDisplay.innerHTML = '<div class="placeholder">æ—¥å¿—å·²æ¸…ç©º...</div>';
                }
            }
        }
        
        // åˆå§‹åŒ–ç®¡ç†å™¨
        document.addEventListener('DOMContentLoaded', () => {
            window.esp32Manager = new SimpleESP32Manager();
            console.log('ESP32æµ‹è¯•ç®¡ç†å™¨å·²åˆå§‹åŒ–');
        });
    </script>
</body>
</html>