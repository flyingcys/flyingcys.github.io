<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ESP32 固件下载测试</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; }
        .btn { padding: 10px 20px; margin: 5px; border: none; border-radius: 4px; cursor: pointer; }
        .btn-primary { background: #007bff; color: white; }
        .btn-secondary { background: #6c757d; color: white; }
        .log { background: #f8f9fa; border: 1px solid #dee2e6; padding: 10px; margin: 10px 0; height: 300px; overflow-y: auto; }
        .log-entry { margin: 2px 0; }
        .success { color: green; }
        .error { color: red; }
        .warning { color: orange; }
        .info { color: blue; }
        .debug { color: gray; }
        select { padding: 8px; margin: 5px; }
    </style>
</head>
<body>
    <h1>ESP32 固件下载测试</h1>
    
    <div>
        <label>设备类型:</label>
        <select id="deviceSelect">
            <option value="T5AI">T5AI</option>
            <option value="ESP32-Series" selected>ESP32-Series (自动检测)</option>
            <option value="ESP32">ESP32</option>
            <option value="ESP32C3">ESP32-C3</option>
            <option value="ESP32S3">ESP32-S3</option>
        </select>
    </div>
    
    <div>
        <button id="testConnectBtn" class="btn btn-primary">🔧 测试连接</button>
        <button id="detectChipBtn" class="btn btn-secondary" disabled>🔍 检测芯片</button>
        <button id="resetDeviceBtn" class="btn btn-secondary" disabled>🔄 重置设备</button>
        <button id="clearLogBtn" class="btn btn-secondary">🗑️ 清空日志</button>
    </div>
    
    <div>
        <label>
            <input type="checkbox" id="debugMode" checked> 调试模式
        </label>
    </div>
    
    <div id="logDisplay" class="log">
        <div class="placeholder">等待操作...</div>
    </div>

    <!-- 引入必要的脚本 -->
    <script src="third_party/esptool-js-umd.bundle.js"></script>
    <script src="downloaders/base-downloader.js"></script>
    <script src="downloaders/esp32/index.js"></script>
    
    <script>
        class SimpleESP32Manager {
            constructor() {
                this.downloader = null;
                this.isConnected = false;
                this.chipInfo = null;
                this.serialPort = null;
                
                this.initEvents();
            }
            
            initEvents() {
                const testBtn = document.getElementById('testConnectBtn');
                const detectBtn = document.getElementById('detectChipBtn');
                const resetBtn = document.getElementById('resetDeviceBtn');
                const clearBtn = document.getElementById('clearLogBtn');
                const deviceSelect = document.getElementById('deviceSelect');
                
                if (testBtn) {
                    testBtn.addEventListener('click', () => this.testConnection());
                }
                
                if (detectBtn) {
                    detectBtn.addEventListener('click', () => this.detectChip());
                }
                
                if (resetBtn) {
                    resetBtn.addEventListener('click', () => this.testReset());
                }
                
                if (clearBtn) {
                    clearBtn.addEventListener('click', () => this.clearLog());
                }
                
                if (deviceSelect) {
                    deviceSelect.addEventListener('change', (e) => {
                        this.log('设备类型已切换: ' + e.target.value, 'info');
                    });
                }
            }
            
            isESP32Device(deviceType) {
                return ['ESP32-Series', 'ESP32', 'ESP32C3', 'ESP32S3'].includes(deviceType);
            }
            
            async testConnection() {
                try {
                    this.log('=== ESP32连接测试开始 ===', 'info');
                    
                    // 检查浏览器支持
                    if (!('serial' in navigator)) {
                        throw new Error('浏览器不支持Web Serial API');
                    }
                    this.log('✅ 浏览器支持Web Serial API', 'success');
                    
                    // 检查ESP32包装器
                    if (typeof ESP32EsptoolJSWrapper === 'undefined') {
                        throw new Error('ESP32EsptoolJSWrapper未加载');
                    }
                    this.log('✅ ESP32EsptoolJSWrapper已加载', 'success');
                    
                    // 请求串口
                    this.log('请选择ESP32设备串口...', 'info');
                    const port = await navigator.serial.requestPort();
                    this.serialPort = port;
                    this.log('✅ 串口选择成功', 'success');
                    
                    // 创建下载器实例
                    this.downloader = new ESP32EsptoolJSWrapper(port, {
                        log: (msg) => this.log('[Wrapper] ' + msg, 'debug'),
                        error: (msg) => this.log('[Wrapper] ' + msg, 'error'),
                        info: (msg) => this.log('[Wrapper] ' + msg, 'info')
                    });
                    this.log('✅ ESP32EsptoolJSWrapper实例创建成功', 'success');
                    
                    // 初始化
                    const initialized = await this.downloader.initialize();
                    if (!initialized) {
                        throw new Error('ESP32包装器初始化失败');
                    }
                    this.log('✅ ESP32包装器初始化成功', 'success');
                    
                    // 连接测试
                    const connected = await this.downloader.connect();
                    if (connected) {
                        this.isConnected = true;
                        this.chipInfo = this.downloader.getChipInfo();
                        
                        this.log('✅ ESP32设备连接成功!', 'success');
                        
                        if (this.chipInfo) {
                            this.log('芯片信息: ' + JSON.stringify(this.chipInfo), 'info');
                        }
                        
                        // 启用检测芯片和重置按钮
                        const detectBtn = document.getElementById('detectChipBtn');
                        const resetBtn = document.getElementById('resetDeviceBtn');
                        if (detectBtn) detectBtn.disabled = false;
                        if (resetBtn) resetBtn.disabled = false;
                        
                        this.log('=== ESP32连接测试完成 ===', 'success');
                        
                    } else {
                        throw new Error('ESP32设备连接失败');
                    }
                    
                } catch (error) {
                    this.log('连接测试失败: ' + error.message, 'error');
                    this.log('💡 提示: 请确保ESP32已连接并进入下载模式（按住BOOT按钮重启）', 'info');
                }
            }
            
            async detectChip() {
                try {
                    this.log('=== ESP32芯片检测开始 ===', 'info');
                    
                    if (!this.isConnected || !this.downloader) {
                        this.log('请先进行连接测试', 'warning');
                        return;
                    }
                    
                    // 复位策略测试
                    this.log('=== 测试复位策略 ===', 'info');
                    
                    try {
                        this.log('🔄 测试ClassicReset复位策略...', 'debug');
                        const classicReset = this.downloader.createClassicReset();
                        await classicReset.reset();
                        this.log('✅ ClassicReset 复位完成', 'success');
                        await new Promise(resolve => setTimeout(resolve, 300));
                    } catch (resetError) {
                        this.log('⚠️ ClassicReset 失败: ' + resetError.message, 'warning');
                    }
                    
                    try {
                        this.log('🔄 测试HardReset复位策略...', 'debug');
                        const hardReset = this.downloader.createHardReset();
                        await hardReset.reset();
                        this.log('✅ HardReset 复位完成', 'success');
                        await new Promise(resolve => setTimeout(resolve, 300));
                    } catch (resetError) {
                        this.log('⚠️ HardReset 失败: ' + resetError.message, 'warning');
                    }
                    
                    // 同步测试
                    this.log('测试设备同步...', 'debug');
                    await this.downloader.sync();
                    this.log('✅ 设备同步成功', 'success');
                    
                    // 读取芯片ID
                    this.log('读取芯片ID...', 'debug');
                    const chipId = await this.downloader.getChipId();
                    if (chipId) {
                        this.log('芯片ID: 0x' + chipId.toString(16), 'success');
                    }
                    
                    // 尝试读取Flash ID
                    this.log('尝试读取Flash ID...', 'debug');
                    try {
                        const flashId = await this.downloader.getFlashId();
                        if (flashId) {
                            this.log('Flash ID: 0x' + flashId.toString(16), 'success');
                        }
                    } catch (e) {
                        this.log('Flash ID读取失败（ROM模式下正常）: ' + e.message, 'warning');
                    }
                    
                    // 获取设备状态
                    const status = this.downloader.getDeviceStatus();
                    this.log('设备状态: 连接=' + status.isConnected + ', loader就绪=' + status.espLoaderReady, 'info');
                    
                    this.log('=== ESP32芯片检测完成 ===', 'success');
                    
                } catch (error) {
                    this.log('芯片检测失败: ' + error.message, 'error');
                }
            }
            
            log(message, type = 'info') {
                try {
                    const debugMode = document.getElementById('debugMode');
                    const isDebugMode = debugMode ? debugMode.checked : true;
                    
                    if (!isDebugMode && type === 'debug') {
                        return; // 非调试模式下不显示debug日志
                    }
                    
                    const logDisplay = document.getElementById('logDisplay');
                    if (!logDisplay) {
                        console.log('[ESP32]', message);
                        return;
                    }
                    
                    const timestamp = new Date().toLocaleTimeString();
                    
                    const logEntry = document.createElement('div');
                    logEntry.className = 'log-entry ' + type;
                    
                    let icon = '📝';
                    switch (type) {
                        case 'success': icon = '✅'; break;
                        case 'error': icon = '❌'; break;
                        case 'warning': icon = '⚠️'; break;
                        case 'debug': icon = '🔍'; break;
                        case 'info': 
                        default: icon = 'ℹ️'; break;
                    }
                    
                    logEntry.innerHTML = 
                        '<span>[' + timestamp + ']</span> ' +
                        '<span>' + icon + '</span> ' +
                        '<span>' + message + '</span>';
                    
                    // 清除占位符
                    const placeholder = logDisplay.querySelector('.placeholder');
                    if (placeholder) {
                        logDisplay.innerHTML = '';
                    }
                    
                    logDisplay.appendChild(logEntry);
                    logDisplay.scrollTop = logDisplay.scrollHeight;
                    
                } catch (error) {
                    console.error('log error:', error);
                    console.log('[ESP32]', message);
                }
            }
            
            async testReset() {
                try {
                    this.log('=== ESP32复位功能测试开始 ===', 'info');
                    
                    if (!this.isConnected || !this.downloader) {
                        this.log('请先进行连接测试', 'warning');
                        return;
                    }
                    
                    // 测试基本DTR/RTS控制
                    this.log('=== 测试DTR/RTS控制功能 ===', 'info');
                    const transport = this.downloader.transport;
                    
                    if (transport && transport.setDTR && transport.setRTS) {
                        this.log('✅ DTR/RTS方法可用', 'success');
                        
                        // 测试DTR控制
                        this.log('🔄 测试DTR控制...', 'debug');
                        await transport.setDTR(false);
                        this.log('DTR设置为LOW', 'debug');
                        await new Promise(resolve => setTimeout(resolve, 100));
                        await transport.setDTR(true);
                        this.log('DTR设置为HIGH', 'debug');
                        await new Promise(resolve => setTimeout(resolve, 100));
                        await transport.setDTR(false);
                        this.log('✅ DTR控制测试完成', 'success');
                        
                        // 测试RTS控制
                        this.log('🔄 测试RTS控制...', 'debug');
                        await transport.setRTS(false);
                        this.log('RTS设置为LOW', 'debug');
                        await new Promise(resolve => setTimeout(resolve, 100));
                        await transport.setRTS(true);
                        this.log('RTS设置为HIGH', 'debug');
                        await new Promise(resolve => setTimeout(resolve, 100));
                        await transport.setRTS(false);
                        this.log('✅ RTS控制测试完成', 'success');
                        
                    } else {
                        this.log('❌ DTR/RTS方法不可用', 'error');
                    }
                    
                    // 测试esptool-js原生reset策略
                    this.log('=== 测试esptool-js原生复位策略 ===', 'info');
                    
                    // ClassicReset (与T5AI类似的复位序列)
                    try {
                        this.log('🔄 测试ClassicReset...', 'debug');
                        const classicReset = this.downloader.createClassicReset();
                        this.log('ClassicReset实例创建成功', 'debug');
                        await classicReset.reset();
                        this.log('✅ ClassicReset执行完成', 'success');
                    } catch (error) {
                        this.log('⚠️ ClassicReset失败: ' + error.message, 'warning');
                    }
                    
                    await new Promise(resolve => setTimeout(resolve, 500));
                    
                    // HardReset 
                    try {
                        this.log('🔄 测试HardReset...', 'debug');
                        const hardReset = this.downloader.createHardReset();
                        this.log('HardReset实例创建成功', 'debug');
                        await hardReset.reset();
                        this.log('✅ HardReset执行完成', 'success');
                    } catch (error) {
                        this.log('⚠️ HardReset失败: ' + error.message, 'warning');
                    }
                    
                    await new Promise(resolve => setTimeout(resolve, 500));
                    
                    // CustomReset - 使用经典序列 
                    try {
                        this.log('🔄 测试CustomReset (经典序列)...', 'debug');
                        // 经典序列: "D0|R1|W100|D1|R0|W50|D0" 
                        // D=DTR, R=RTS, W=Wait
                        const customReset = this.downloader.createCustomReset("D0|R1|W100|D1|R0|W50|D0");
                        this.log('CustomReset实例创建成功', 'debug');
                        await customReset.reset();
                        this.log('✅ CustomReset执行完成', 'success');
                    } catch (error) {
                        this.log('⚠️ CustomReset失败: ' + error.message, 'warning');
                    }
                    
                    this.log('=== ESP32复位功能测试完成 ===', 'success');
                    this.log('💡 提示: DTR和RTS功能已验证，与T5AI和esptool-js兼容', 'info');
                    
                } catch (error) {
                    this.log('复位测试失败: ' + error.message, 'error');
                }
            }
            
            clearLog() {
                const logDisplay = document.getElementById('logDisplay');
                if (logDisplay) {
                    logDisplay.innerHTML = '<div class="placeholder">日志已清空...</div>';
                }
            }
        }
        
        // 初始化管理器
        document.addEventListener('DOMContentLoaded', () => {
            window.esp32Manager = new SimpleESP32Manager();
            console.log('ESP32测试管理器已初始化');
        });
    </script>
</body>
</html>